{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":"python","separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"About"},{"location":"concepts/architecture/","text":"Architecture Fybrik takes a modular approach to provide an open platform for controlling and securing the use of data across an organization. The figure below showcases the current architecture of the Fybrik platform, running on top of Kubernetes. The storage systems shown in the lower half of the figure are merely an example. The core parts of Fybrik are based on Kubernetes controllers and Custom Resource Definitions (CRDs) in order to define its work items and reconcile the state of them. The primary interaction object for a data user is the FybrikApplication CRD where a user defines which data should be used for which purpose. The following chart and description describe the architecture and components of Fybrik relative to when they are used. Before the data user can perform any actions a data operator has to install Fybrik and modules. Modules describe capabilities that can be included in a data plane. These may be existing open source or third party service, or custom ones. The module of a service indicates the capabilities it supports, the formats and interfaces, and how to deploy the service. Modules may describe externally deployed services, or services deployed by fybrik. Examples of modules are those that provide read/write access or produce implicit copies that serve as lower latency caches of remote assets. Modules also may also perform actions usesd to enforce data governance policy decisions, such as masking or redaction as examples. Fybrik connects to external services to receive data governance decisions, metadata about datasets and credentials. Policies, assets and access credentials to the assets have to be defined before the user can run an application. The current abstraction supports 2 different connectors : one for data catalog and one for policy manager. It is designed in an open way so that multiple different catalog and policy frameworks of all kinds of cloud and on-prem systems can be supported. The data steward configures policies in an external policy manager over assets defined in an external data catalog. Dataset credentials are retrieved from Vault by using Vault API . Vault uses a custom secret engine implemented with HashiCorp Vault plugins system to retrieve the credentials from where they are stored (data catalog for example). Once a developer submits a FybrikApplication CRD to Kubernetes, the FybrikApplicationController will make sure that all the specs are fulfilled and will make sure that the data is read/written/copied/deleted according to the data governance policies. The FybrikApplication holds metadata about the application such as the data assets required by the application, the processing purpose and the method of access the user wishes (protocol e.g. S3 or Arrow flight). It uses this information to check with the data governance policy manager (4) if the data flow requested is allowed and whether restrictive policies such as masking or hashing have to be applied. It compiles plotters based on the governance decisions received via the data governance policy connector and chooses the modules (5) which are best fit for the requirements that the user specified regarding the access protocol and availability, and based on the config policies defined. As data assets may reside in different clusters/clouds a Blueprint CRD is created for each cluster, containing the information regarding the services to be deployed or configured in the given cluster. Depending on the setup the PlotterController will use various methods to distribute the blueprints. In a multi cluster setup the default distribution implementation is using Razee to control remote blueprints, but several multi-cloud tools could be used as a replacement. The PlotterController also collects statuses and distributes updates of said blueprints. Once all the blueprints on all clusters are ready the plotter is marked as ready. A single blueprint contains the specification of all assets that shall be accessed in a single cluster by a single application. The BlueprintController makes sure that a blueprint can deploy all needed modules (8) and (9) and tracks their status (10). Once e.g. an implicit-copy module finishes the copy the blueprint is also in a ready state. A read or write module is in ready state as soon as the proxy service such as the arrow-flight module is running. In this example an implicit-copy module copies data from a remote postgres database into a S3 compatible ceph instance. The arrow-flight module then locally serves the data to the user via the Arrow flight protocol. Credentials are handled by the modules (11) and are never exposed to the user. The application reads from and writes data to allowed targets. Requests are handled by FybrikModule instances(12). The application can not interact with unauthorized targets.","title":"Architecture"},{"location":"concepts/architecture/#architecture","text":"Fybrik takes a modular approach to provide an open platform for controlling and securing the use of data across an organization. The figure below showcases the current architecture of the Fybrik platform, running on top of Kubernetes. The storage systems shown in the lower half of the figure are merely an example. The core parts of Fybrik are based on Kubernetes controllers and Custom Resource Definitions (CRDs) in order to define its work items and reconcile the state of them. The primary interaction object for a data user is the FybrikApplication CRD where a user defines which data should be used for which purpose. The following chart and description describe the architecture and components of Fybrik relative to when they are used. Before the data user can perform any actions a data operator has to install Fybrik and modules. Modules describe capabilities that can be included in a data plane. These may be existing open source or third party service, or custom ones. The module of a service indicates the capabilities it supports, the formats and interfaces, and how to deploy the service. Modules may describe externally deployed services, or services deployed by fybrik. Examples of modules are those that provide read/write access or produce implicit copies that serve as lower latency caches of remote assets. Modules also may also perform actions usesd to enforce data governance policy decisions, such as masking or redaction as examples. Fybrik connects to external services to receive data governance decisions, metadata about datasets and credentials. Policies, assets and access credentials to the assets have to be defined before the user can run an application. The current abstraction supports 2 different connectors : one for data catalog and one for policy manager. It is designed in an open way so that multiple different catalog and policy frameworks of all kinds of cloud and on-prem systems can be supported. The data steward configures policies in an external policy manager over assets defined in an external data catalog. Dataset credentials are retrieved from Vault by using Vault API . Vault uses a custom secret engine implemented with HashiCorp Vault plugins system to retrieve the credentials from where they are stored (data catalog for example). Once a developer submits a FybrikApplication CRD to Kubernetes, the FybrikApplicationController will make sure that all the specs are fulfilled and will make sure that the data is read/written/copied/deleted according to the data governance policies. The FybrikApplication holds metadata about the application such as the data assets required by the application, the processing purpose and the method of access the user wishes (protocol e.g. S3 or Arrow flight). It uses this information to check with the data governance policy manager (4) if the data flow requested is allowed and whether restrictive policies such as masking or hashing have to be applied. It compiles plotters based on the governance decisions received via the data governance policy connector and chooses the modules (5) which are best fit for the requirements that the user specified regarding the access protocol and availability, and based on the config policies defined. As data assets may reside in different clusters/clouds a Blueprint CRD is created for each cluster, containing the information regarding the services to be deployed or configured in the given cluster. Depending on the setup the PlotterController will use various methods to distribute the blueprints. In a multi cluster setup the default distribution implementation is using Razee to control remote blueprints, but several multi-cloud tools could be used as a replacement. The PlotterController also collects statuses and distributes updates of said blueprints. Once all the blueprints on all clusters are ready the plotter is marked as ready. A single blueprint contains the specification of all assets that shall be accessed in a single cluster by a single application. The BlueprintController makes sure that a blueprint can deploy all needed modules (8) and (9) and tracks their status (10). Once e.g. an implicit-copy module finishes the copy the blueprint is also in a ready state. A read or write module is in ready state as soon as the proxy service such as the arrow-flight module is running. In this example an implicit-copy module copies data from a remote postgres database into a S3 compatible ceph instance. The arrow-flight module then locally serves the data to the user via the Arrow flight protocol. Credentials are handled by the modules (11) and are never exposed to the user. The application reads from and writes data to allowed targets. Requests are handled by FybrikModule instances(12). The application can not interact with unauthorized targets.","title":"Architecture"},{"location":"concepts/config-policies/","text":"Configuration Policies What are configuration policies? Configuration policies are the mechanism via which the organization may influence the construction of the data plane, taking into account infrastructure capabilities and costs. Fybrik takes into account the workload context, the data metadata, the data governance policies and the configuration policies when defining the data plane. The configuration policies influence what capabilities should be deployed (e.g. read, copy), in which clusters they should be deployed, and selection of the most appropriate module that implements the capability. Input to policies The input object includes general application data such as workload cluster and application properties, as well as dataset details (user requirements, metadata, required actions). Available properties: - cluster.name : name of the workload cluster - cluster.metadata.region : region of the workload cluster - properties : application/workload properties defined in FybrikApplication, e.g. properties.intent - request.metadata : asset metadata as defined in catalog taxonomy, e.g request.metadata.geography - usage : a set of boolean properties associated with data use: usage.read , usage.write , usage.copy Syntax Policies are written in rego files. Each file declares a package adminconfig . Rules are written in the following syntax: config[{capability: decision}] where capability represents a required module capability, such as \"read\", \"write\", \"transform\" and \"copy\". decision is a JSON structure that matches Decision defined above. { \"policy\": {\"ID\": <id>, \"policySetID\": <setId>, \"description\": <description>}, \"deploy\": <true, false>, \"restrictions\": { \"modules\": <map {key, list-of-values}>, \"clusters\": <map {key, list-of-values}>, }, } For example, the policy above restricts the choice of clusters and modules for a read capability by narrowing the choice of deployment clusters to the workload cluster, and restricting the module type to service. config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-ID\", \"description\":\"Deploy read as a service in the workload cluster\"} clusters := { \"name\" : [ input.workload.cluster.name ] } modules := { \"type\": [\"service\"]} decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters, \"modules\": modules}} } policy provides policy metadata: unique ID, human-readable description and policySetID (see ### Policy Set ID) restrictions provides restrictions for modules , clusters and storageaccounts . Each restriction provides a list of allowed values for a property of module/cluster/storageaccount object. For example, to restrict a module type to either \"service\" or \"plugin\", we'll use \"type\" as a key, and [ \"service\",\"plugin ] as a list of allowed values. Properties of a module can be found inside FybrikModule Spec. Properties of a storage account are listed inside FybrikStorageAccount . Cluster is not a custom resource. It has the following properties: - name: cluster name - metadata.region: cluster region - metadata.zone: cluster zone deploy receives \"true\"/\"false\" values. These values indicate whether the capability should or should not be deployed. If not specified in the policy, it's up to Fybrik to decide on the capability deployment. Policy Set ID Fybrik supports evaluating different sets of policies for different FybrikApplications. It is possible to define a policy for a specific policySetID which will be trigered only if it matches the policySetID defined in FybrikApplication. If a policy does not specify a policy set id, it will be considered as relevant for all FybrikApplications. In a similar way, all policies are relevant for a FybrikApplication that does not specify a policy set id, to support a use-case of a single policy set for all. Out of the box policies Out of the box policies come with the fybrik deployment. They define the deployment of basic capabilities, such as read and write. package adminconfig config[{\"read\": decision}] { read_request := input.request.usage.read policy := {\"ID\": \"read-default\", \"description\":\"Read capability is requested for read workloads\"} decision := {\"policy\": policy, \"deploy\": read_request} } config[{\"write\": decision}] { write_request := input.request.usage.write policy := {\"ID\": \"write-default\", \"description\":\"Write capability is requested for workloads that write data\"} decision := {\"policy\": policy, \"deploy\": write_request} } Extended policies The extended policies define advanced deployment requirements, such as where read or transform modules should run, what should be the scope of module deployments, and more. The policies below are provided as a sample and can be updated for the production deployment. package adminconfig # configure where transformations take place config[{\"transform\": decision}] { policy := {\"ID\": \"transform-geo\", \"description\":\"Governance based transformations must take place in the geography where the data is stored\"} clusters := { \"metadata.region\" : [ input.request.dataset.geography ] } decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters}} } # configure the scope of the read capability config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-scope\", \"description\":\"Deploy read at the workload scope\"} decision := {\"policy\": policy, \"restrictions\": {\"modules\": {\"capabilities.scope\" : [\"workload\"]}}} } # configure where the read capability will be deployed config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-location\", \"description\":\"Deploy read in the workload cluster\"} clusters := { \"name\" : [ input.workload.cluster.name ] } decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters}} } # allow implicit copies by default config[{\"copy\": decision}] { input.request.usage.read == true policy := {\"ID\": \"copy-default\", \"description\":\"Implicit copies are allowed in read scenarios\"} decision := {\"policy\": policy} } # configure when implicit copies should be made config[{\"copy\": decision}] { input.request.usage.read == true input.request.dataset.geography != input.workload.cluster.metadata.region count(input.actions) > 0 clusters := { \"metadata.region\" : [ input.request.dataset.geography ] } policy := {\"ID\": \"copy-remote\", \"description\":\"Implicit copies should be used if the data is in a different region than the compute, and transformations are required\"} decision := {\"policy\": policy, \"deploy\": true, \"restrictions\": {\"clusters\": clusters}} }","title":"Configuration Policies"},{"location":"concepts/config-policies/#configuration-policies","text":"","title":"Configuration Policies"},{"location":"concepts/config-policies/#what-are-configuration-policies","text":"Configuration policies are the mechanism via which the organization may influence the construction of the data plane, taking into account infrastructure capabilities and costs. Fybrik takes into account the workload context, the data metadata, the data governance policies and the configuration policies when defining the data plane. The configuration policies influence what capabilities should be deployed (e.g. read, copy), in which clusters they should be deployed, and selection of the most appropriate module that implements the capability.","title":"What are configuration policies?"},{"location":"concepts/config-policies/#input-to-policies","text":"The input object includes general application data such as workload cluster and application properties, as well as dataset details (user requirements, metadata, required actions). Available properties: - cluster.name : name of the workload cluster - cluster.metadata.region : region of the workload cluster - properties : application/workload properties defined in FybrikApplication, e.g. properties.intent - request.metadata : asset metadata as defined in catalog taxonomy, e.g request.metadata.geography - usage : a set of boolean properties associated with data use: usage.read , usage.write , usage.copy","title":"Input to policies"},{"location":"concepts/config-policies/#syntax","text":"Policies are written in rego files. Each file declares a package adminconfig . Rules are written in the following syntax: config[{capability: decision}] where capability represents a required module capability, such as \"read\", \"write\", \"transform\" and \"copy\". decision is a JSON structure that matches Decision defined above. { \"policy\": {\"ID\": <id>, \"policySetID\": <setId>, \"description\": <description>}, \"deploy\": <true, false>, \"restrictions\": { \"modules\": <map {key, list-of-values}>, \"clusters\": <map {key, list-of-values}>, }, } For example, the policy above restricts the choice of clusters and modules for a read capability by narrowing the choice of deployment clusters to the workload cluster, and restricting the module type to service. config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-ID\", \"description\":\"Deploy read as a service in the workload cluster\"} clusters := { \"name\" : [ input.workload.cluster.name ] } modules := { \"type\": [\"service\"]} decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters, \"modules\": modules}} } policy provides policy metadata: unique ID, human-readable description and policySetID (see ### Policy Set ID) restrictions provides restrictions for modules , clusters and storageaccounts . Each restriction provides a list of allowed values for a property of module/cluster/storageaccount object. For example, to restrict a module type to either \"service\" or \"plugin\", we'll use \"type\" as a key, and [ \"service\",\"plugin ] as a list of allowed values. Properties of a module can be found inside FybrikModule Spec. Properties of a storage account are listed inside FybrikStorageAccount . Cluster is not a custom resource. It has the following properties: - name: cluster name - metadata.region: cluster region - metadata.zone: cluster zone deploy receives \"true\"/\"false\" values. These values indicate whether the capability should or should not be deployed. If not specified in the policy, it's up to Fybrik to decide on the capability deployment.","title":"Syntax"},{"location":"concepts/config-policies/#policy-set-id","text":"Fybrik supports evaluating different sets of policies for different FybrikApplications. It is possible to define a policy for a specific policySetID which will be trigered only if it matches the policySetID defined in FybrikApplication. If a policy does not specify a policy set id, it will be considered as relevant for all FybrikApplications. In a similar way, all policies are relevant for a FybrikApplication that does not specify a policy set id, to support a use-case of a single policy set for all.","title":"Policy Set ID"},{"location":"concepts/config-policies/#out-of-the-box-policies","text":"Out of the box policies come with the fybrik deployment. They define the deployment of basic capabilities, such as read and write. package adminconfig config[{\"read\": decision}] { read_request := input.request.usage.read policy := {\"ID\": \"read-default\", \"description\":\"Read capability is requested for read workloads\"} decision := {\"policy\": policy, \"deploy\": read_request} } config[{\"write\": decision}] { write_request := input.request.usage.write policy := {\"ID\": \"write-default\", \"description\":\"Write capability is requested for workloads that write data\"} decision := {\"policy\": policy, \"deploy\": write_request} }","title":"Out of the box policies"},{"location":"concepts/config-policies/#extended-policies","text":"The extended policies define advanced deployment requirements, such as where read or transform modules should run, what should be the scope of module deployments, and more. The policies below are provided as a sample and can be updated for the production deployment. package adminconfig # configure where transformations take place config[{\"transform\": decision}] { policy := {\"ID\": \"transform-geo\", \"description\":\"Governance based transformations must take place in the geography where the data is stored\"} clusters := { \"metadata.region\" : [ input.request.dataset.geography ] } decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters}} } # configure the scope of the read capability config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-scope\", \"description\":\"Deploy read at the workload scope\"} decision := {\"policy\": policy, \"restrictions\": {\"modules\": {\"capabilities.scope\" : [\"workload\"]}}} } # configure where the read capability will be deployed config[{\"read\": decision}] { input.request.usage.read == true policy := {\"ID\": \"read-location\", \"description\":\"Deploy read in the workload cluster\"} clusters := { \"name\" : [ input.workload.cluster.name ] } decision := {\"policy\": policy, \"restrictions\": {\"clusters\": clusters}} } # allow implicit copies by default config[{\"copy\": decision}] { input.request.usage.read == true policy := {\"ID\": \"copy-default\", \"description\":\"Implicit copies are allowed in read scenarios\"} decision := {\"policy\": policy} } # configure when implicit copies should be made config[{\"copy\": decision}] { input.request.usage.read == true input.request.dataset.geography != input.workload.cluster.metadata.region count(input.actions) > 0 clusters := { \"metadata.region\" : [ input.request.dataset.geography ] } policy := {\"ID\": \"copy-remote\", \"description\":\"Implicit copies should be used if the data is in a different region than the compute, and transformations are required\"} decision := {\"policy\": policy, \"deploy\": true, \"restrictions\": {\"clusters\": clusters}} }","title":"Extended policies"},{"location":"concepts/connectors/","text":"Connectors The project currently has two extension mechanisms, namely connectors and modules. This page describes what connectors are and what connectors are installed using the default Fybrik installation. What are connectors? Connectors are Open API services that the Fybrik control plane uses to connect to external systems. Specifically, the control plane needs connectors to a data catalog and a data governance policy manager. These connector services are deployed alongside the control plane. Can I write my own connectors? Yes. Fybrik provides some default connectors described in this page but anyone can develop their own connectors. A connector needs to implement one or more of the interfaces described in the API documentation , depending on the connector type. Note that a single Kubernetes service can implement all interfaces if the system it connects to, supports the required functionality, but it can also be different services. In addition, to benefit from the control plane security feature ensure that the Pods of your connector: 1. Have a fybrik.io/componentType: connector label 1. Have a sidecar.istio.io/inject: \"true\" annotation Connector types Data catalog Fybrik assumes the use of an enterprise data catalog. For example, to reference a required data asset in a FybrikApplication resource, you provide a link to the asset in the catalog. The catalog provides metadata about the asset such as security tags. It also provides connection information to describe how to connect to the data source to consume the data. Fybrik uses the metadata provided by the catalog both to enable seamless connectivity to the data and as input to making data governance policy decisions. The data user is not concerned with any of it and just selects the data that it needs regardless of where the data resides. Fybrik is not a data catalog. Instead, it links to existing data catalogs using connectors. The default installation of Fybrik installs Katalog , a built-in data catalog using Kubernetes CRDs used for evaluation. A connector to ODPi Egeria is also available. Policy manager Data governance policies are defined externally in the data governance manager of choice. Enforcing data governance policies requires a Policy Decision Point (PDP) that dictates what enforcement actions need to take place. Fybrik supports a wide and extendable set of enforcement actions to perform on data read, copy, (future) write or delete. These include transformation of data, verification of the data, and various restrictions on the external activity of an application that can access the data. A PDP returns a list of enforcement actions given a set of policies and specific context about the application and the data it uses. Fybrik includes a PDP that is powered by Open Policy Agent (OPA). However, the PDP can also use external policy managers via connectors, to cover some or even all policy types.","title":"Connectors"},{"location":"concepts/connectors/#connectors","text":"The project currently has two extension mechanisms, namely connectors and modules. This page describes what connectors are and what connectors are installed using the default Fybrik installation.","title":"Connectors"},{"location":"concepts/connectors/#what-are-connectors","text":"Connectors are Open API services that the Fybrik control plane uses to connect to external systems. Specifically, the control plane needs connectors to a data catalog and a data governance policy manager. These connector services are deployed alongside the control plane.","title":"What are connectors?"},{"location":"concepts/connectors/#can-i-write-my-own-connectors","text":"Yes. Fybrik provides some default connectors described in this page but anyone can develop their own connectors. A connector needs to implement one or more of the interfaces described in the API documentation , depending on the connector type. Note that a single Kubernetes service can implement all interfaces if the system it connects to, supports the required functionality, but it can also be different services. In addition, to benefit from the control plane security feature ensure that the Pods of your connector: 1. Have a fybrik.io/componentType: connector label 1. Have a sidecar.istio.io/inject: \"true\" annotation","title":"Can I write my own connectors?"},{"location":"concepts/connectors/#connector-types","text":"","title":"Connector types"},{"location":"concepts/connectors/#data-catalog","text":"Fybrik assumes the use of an enterprise data catalog. For example, to reference a required data asset in a FybrikApplication resource, you provide a link to the asset in the catalog. The catalog provides metadata about the asset such as security tags. It also provides connection information to describe how to connect to the data source to consume the data. Fybrik uses the metadata provided by the catalog both to enable seamless connectivity to the data and as input to making data governance policy decisions. The data user is not concerned with any of it and just selects the data that it needs regardless of where the data resides. Fybrik is not a data catalog. Instead, it links to existing data catalogs using connectors. The default installation of Fybrik installs Katalog , a built-in data catalog using Kubernetes CRDs used for evaluation. A connector to ODPi Egeria is also available.","title":"Data catalog"},{"location":"concepts/connectors/#policy-manager","text":"Data governance policies are defined externally in the data governance manager of choice. Enforcing data governance policies requires a Policy Decision Point (PDP) that dictates what enforcement actions need to take place. Fybrik supports a wide and extendable set of enforcement actions to perform on data read, copy, (future) write or delete. These include transformation of data, verification of the data, and various restrictions on the external activity of an application that can access the data. A PDP returns a list of enforcement actions given a set of policies and specific context about the application and the data it uses. Fybrik includes a PDP that is powered by Open Policy Agent (OPA). However, the PDP can also use external policy managers via connectors, to cover some or even all policy types.","title":"Policy manager"},{"location":"concepts/introduction/","text":"Introduction Fybrik is a cloud native platform to unify data access and governance, enabling business agility while securing enterprise data. By providing access and use of data only via the platform, Fybrik brings together access and governance for data, greatly reducing risk of data loss. Fybrik allows: Data users to use data in a self-service model without manual processes, without needing to confer with data stewards, and without dealing with credentials. Use common tools and frameworks for reading from and exporting data to data lakes or data warehouses. Data stewards to control data usage by applications. Use the organization's policy manager and data catalog of choice and let Fybrik automatically enforce data governance policies, whether they be based on laws, industry standards or enterprise policies. Data operators to automate data lifecycle management removing the need for manual processes and custom jobs created by data operators, providing them with config policies to optimize the data flows orchestrated by fybrik. How does it work? The inputs to Fybrik are declarative definitions with separation of aspects: Data stewards input definitions related to data governance and security Data users input definitions related to data usage in the business logic of their applications Data operators input definitions related to infrastructure and available resources Upon creation or change of any definition, Fybrik compiles together relevant inputs into a plotter describing the flow of data between the application and the data sources/destinations (data plane). The plotter augments the application workload and data sources with additional services and functions packed as pluggable modules. This creates a data path that: Integrates business logic with non-functional data centric requirements such as enabling data access regardless of its physical location, caching, lineage tracking, etc. Enforces governance relating to the data and its lifecycle; including limiting what data the business logic can access, performing transformations as needed, controlling what the business logic can export and to where Makes data available in locations where it is needed. Thus, in a multi cluster scenario it may copy data from one location to another, something known as an implicit copy. The implicit copy is deleted when no longer needed. Fybrik is an open solution that can be extended to work with a wide range of tools and data stores. For example, the injectable modules and the connectors to external systems (e.g., to a data catalog) can all be third party. The logic used by fybrik to generate the data planes is customizable. An organization can determine how best its infrastructure should be leveraged via config policies Applications Fybrik considers applications as first level entities. Before running a workload, an application needs to be registered to a Fybrik control plane by applying a FybrikApplication resource. This is the declarative definition provided by the data user. The registration provides context about the application such as the purpose for which it's running, the data assets that it accesses, and a selector to identify the workload. Additional context such as geo-location is extracted from the platform. The actions taken by Fybrik are based on policies and the context of the application. Specifically, Fybrik does not consider end-users of an application. It is the responsibility of the application to implement mechanisms such as end user authentication if required, e.g. using Istio authorization with JWT . There are specific situations in which there is no workload associated with a FybrikApplication resource. Examples of these are requests to ingest data into a governed environment, or (future) requests to clean up data in the governed environment based on data governance policies. Security While Fybrik handles enforcement of data governance policies, if one could access the data not through the platform then we lose control over data usage. For this reason, Fybrik does not let user applications ever observe data access credentials, neither for externally created data assets nor for data assets created by the Fybrik control plane and applications running in it. Instead, modules run in the data path to handle access to data, including passing the data access credentials to upstream data stores. Security is preserved by authorizing the applications based on their Pod identities. Multicluster Fybrik supports data paths that access data stores that are external to the cluster such as cloud managed object stores or databases as well as data stores within the cluster such as databases running in Kubernetes. All applications and modules however will run within a cluster that has Fybrik installed. Multi-cloud and hybrid cloud scenarios are supported out of the box by running Fybrik in multiple Kubernetes clusters and configuring the manager to use a multi-cluster coordination mechanism such as Razee. This enables cases such as running, for example, transformations on-prem while creating an implicit copy of an on-prem SoR table to a public cloud storage system.","title":"Introduction"},{"location":"concepts/introduction/#introduction","text":"Fybrik is a cloud native platform to unify data access and governance, enabling business agility while securing enterprise data. By providing access and use of data only via the platform, Fybrik brings together access and governance for data, greatly reducing risk of data loss. Fybrik allows: Data users to use data in a self-service model without manual processes, without needing to confer with data stewards, and without dealing with credentials. Use common tools and frameworks for reading from and exporting data to data lakes or data warehouses. Data stewards to control data usage by applications. Use the organization's policy manager and data catalog of choice and let Fybrik automatically enforce data governance policies, whether they be based on laws, industry standards or enterprise policies. Data operators to automate data lifecycle management removing the need for manual processes and custom jobs created by data operators, providing them with config policies to optimize the data flows orchestrated by fybrik.","title":"Introduction"},{"location":"concepts/introduction/#how-does-it-work","text":"The inputs to Fybrik are declarative definitions with separation of aspects: Data stewards input definitions related to data governance and security Data users input definitions related to data usage in the business logic of their applications Data operators input definitions related to infrastructure and available resources Upon creation or change of any definition, Fybrik compiles together relevant inputs into a plotter describing the flow of data between the application and the data sources/destinations (data plane). The plotter augments the application workload and data sources with additional services and functions packed as pluggable modules. This creates a data path that: Integrates business logic with non-functional data centric requirements such as enabling data access regardless of its physical location, caching, lineage tracking, etc. Enforces governance relating to the data and its lifecycle; including limiting what data the business logic can access, performing transformations as needed, controlling what the business logic can export and to where Makes data available in locations where it is needed. Thus, in a multi cluster scenario it may copy data from one location to another, something known as an implicit copy. The implicit copy is deleted when no longer needed. Fybrik is an open solution that can be extended to work with a wide range of tools and data stores. For example, the injectable modules and the connectors to external systems (e.g., to a data catalog) can all be third party. The logic used by fybrik to generate the data planes is customizable. An organization can determine how best its infrastructure should be leveraged via config policies","title":"How does it work?"},{"location":"concepts/introduction/#applications","text":"Fybrik considers applications as first level entities. Before running a workload, an application needs to be registered to a Fybrik control plane by applying a FybrikApplication resource. This is the declarative definition provided by the data user. The registration provides context about the application such as the purpose for which it's running, the data assets that it accesses, and a selector to identify the workload. Additional context such as geo-location is extracted from the platform. The actions taken by Fybrik are based on policies and the context of the application. Specifically, Fybrik does not consider end-users of an application. It is the responsibility of the application to implement mechanisms such as end user authentication if required, e.g. using Istio authorization with JWT . There are specific situations in which there is no workload associated with a FybrikApplication resource. Examples of these are requests to ingest data into a governed environment, or (future) requests to clean up data in the governed environment based on data governance policies.","title":"Applications"},{"location":"concepts/introduction/#security","text":"While Fybrik handles enforcement of data governance policies, if one could access the data not through the platform then we lose control over data usage. For this reason, Fybrik does not let user applications ever observe data access credentials, neither for externally created data assets nor for data assets created by the Fybrik control plane and applications running in it. Instead, modules run in the data path to handle access to data, including passing the data access credentials to upstream data stores. Security is preserved by authorizing the applications based on their Pod identities.","title":"Security"},{"location":"concepts/introduction/#multicluster","text":"Fybrik supports data paths that access data stores that are external to the cluster such as cloud managed object stores or databases as well as data stores within the cluster such as databases running in Kubernetes. All applications and modules however will run within a cluster that has Fybrik installed. Multi-cloud and hybrid cloud scenarios are supported out of the box by running Fybrik in multiple Kubernetes clusters and configuring the manager to use a multi-cluster coordination mechanism such as Razee. This enables cases such as running, for example, transformations on-prem while creating an implicit copy of an on-prem SoR table to a public cloud storage system.","title":"Multicluster"},{"location":"concepts/modules/","text":"Modules The project currently has two extension mechanisms, namely connectors and modules. This page describes what modules are and how they are leveraged by the control plane to build the data plane flow. What are modules? As described in the architecture page, the control plane generates a description of a data plane based on policies and application requirements. This is known as a blueprint, and includes components that are deployed by the control plane to fulfill different data-centric requirements. For example, a component that can mask data can be used to enforce a data masking policy, or a component that copies data may be used to create a local data copy to meet performance requirements, etc. Modules are the way to describe such data plane components and make them available to the control plane. A module is packaged as a Helm chart that the control plane can install to a workload's data plane. To make a module available to the control plane it must be registered by applying a FybrikModule CRD. The functionality described by the module may be deployed (a) per workload, or (b) it may be composed of one or more components that run independent of the workload and its associated control plane. In the case of (a), the control plane handles the deployment of the functional component. In the case of (b) where the functionality of the module runs independently and handles requests from multiple workloads, a client module is what is deployed by the control plane. This client module passes parameters to the external component(s) and monitors the status and results of the requests to the external component(s). The following diagram shows an example with an Arrow Flight module that is fully deployed by the control plane and a second module where the client is deployed by the control plane but the ETL component providing the functionality has been independently deployed and supports multiple workloads. Components that make up a module There are several parts to a module: Optional external component(s): deployed and managed independently of Fybrik. Module Workload : the workload that runs once the Helm chart is installed by the control plane. Can be a client to the external component(s) or be independent. Module Helm Chart : the package containing the module workload that the control plane installs as part of a data plane. FybrikModule YAML : describes the functional capabilities, supported interfaces, and has links to the Module Helm chart. Registering a module To make the control plane aware of the module so that it can be included in appropriate workload data flows, the administrator must apply the FybrikModule YAML in the fybrik-system namespace. This makes the control plane aware of the existence of the module. Note that it does not check that the module's helm chart exists. For example, the following registers the arrow-flight-module : kubectl apply -f https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml -n fybrik-system When is a module used? There are three main data flows in which modules may be used: * Read - preparing data to be read and/or actually reading the data * Write - writing a new data set or appending data to an existing data set * Copy - for performing an implicit data copy on behalf of the application. The decision to do an implicit copy is made by the control plane, typically for performance or governance reasons. A module may be used in one or more of these flows, as is indicated in the module's yaml file. Control plane choice of modules A user workload description FybrikApplicaton includes a list of the data sets required, the technologies that will be used to access them, the access type (e.g. read, copy), information about the location and reason for the use of the data. This information together with input from data and enterprise policies , determine which modules are chosen by the control plane and where they are deployed. Available modules The table below lists the currently available modules: Name Description FybrikModule Prerequisite arrow-flight-module reading datasets while performing data transformations https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml implicit-copy copies data between any two supported data stores, for example S3 and Kafka, and applies transformations. https://raw.githubusercontent.com/fybrik/data-movement-operator/master/modules/implicit-copy-batch-module.yaml https://raw.githubusercontent.com/fybrik/data-movement-operator/master/modules/implicit-copy-stream-module.yaml - Datashim deployment. - FybrikStorageAccount resource deployed in the control plane namespace to hold the details of the storage which is used by the module for coping the data. Contributing Read Module Development for details on the components that make up a module and how to create a module.","title":"Modules"},{"location":"concepts/modules/#modules","text":"The project currently has two extension mechanisms, namely connectors and modules. This page describes what modules are and how they are leveraged by the control plane to build the data plane flow.","title":"Modules"},{"location":"concepts/modules/#what-are-modules","text":"As described in the architecture page, the control plane generates a description of a data plane based on policies and application requirements. This is known as a blueprint, and includes components that are deployed by the control plane to fulfill different data-centric requirements. For example, a component that can mask data can be used to enforce a data masking policy, or a component that copies data may be used to create a local data copy to meet performance requirements, etc. Modules are the way to describe such data plane components and make them available to the control plane. A module is packaged as a Helm chart that the control plane can install to a workload's data plane. To make a module available to the control plane it must be registered by applying a FybrikModule CRD. The functionality described by the module may be deployed (a) per workload, or (b) it may be composed of one or more components that run independent of the workload and its associated control plane. In the case of (a), the control plane handles the deployment of the functional component. In the case of (b) where the functionality of the module runs independently and handles requests from multiple workloads, a client module is what is deployed by the control plane. This client module passes parameters to the external component(s) and monitors the status and results of the requests to the external component(s). The following diagram shows an example with an Arrow Flight module that is fully deployed by the control plane and a second module where the client is deployed by the control plane but the ETL component providing the functionality has been independently deployed and supports multiple workloads.","title":"What are modules?"},{"location":"concepts/modules/#components-that-make-up-a-module","text":"There are several parts to a module: Optional external component(s): deployed and managed independently of Fybrik. Module Workload : the workload that runs once the Helm chart is installed by the control plane. Can be a client to the external component(s) or be independent. Module Helm Chart : the package containing the module workload that the control plane installs as part of a data plane. FybrikModule YAML : describes the functional capabilities, supported interfaces, and has links to the Module Helm chart.","title":"Components that make up a module"},{"location":"concepts/modules/#registering-a-module","text":"To make the control plane aware of the module so that it can be included in appropriate workload data flows, the administrator must apply the FybrikModule YAML in the fybrik-system namespace. This makes the control plane aware of the existence of the module. Note that it does not check that the module's helm chart exists. For example, the following registers the arrow-flight-module : kubectl apply -f https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml -n fybrik-system","title":"Registering a module"},{"location":"concepts/modules/#when-is-a-module-used","text":"There are three main data flows in which modules may be used: * Read - preparing data to be read and/or actually reading the data * Write - writing a new data set or appending data to an existing data set * Copy - for performing an implicit data copy on behalf of the application. The decision to do an implicit copy is made by the control plane, typically for performance or governance reasons. A module may be used in one or more of these flows, as is indicated in the module's yaml file.","title":"When is a module used?"},{"location":"concepts/modules/#control-plane-choice-of-modules","text":"A user workload description FybrikApplicaton includes a list of the data sets required, the technologies that will be used to access them, the access type (e.g. read, copy), information about the location and reason for the use of the data. This information together with input from data and enterprise policies , determine which modules are chosen by the control plane and where they are deployed.","title":"Control plane choice of modules"},{"location":"concepts/modules/#available-modules","text":"The table below lists the currently available modules: Name Description FybrikModule Prerequisite arrow-flight-module reading datasets while performing data transformations https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml implicit-copy copies data between any two supported data stores, for example S3 and Kafka, and applies transformations. https://raw.githubusercontent.com/fybrik/data-movement-operator/master/modules/implicit-copy-batch-module.yaml https://raw.githubusercontent.com/fybrik/data-movement-operator/master/modules/implicit-copy-stream-module.yaml - Datashim deployment. - FybrikStorageAccount resource deployed in the control plane namespace to hold the details of the storage which is used by the module for coping the data.","title":"Available modules"},{"location":"concepts/modules/#contributing","text":"Read Module Development for details on the components that make up a module and how to create a module.","title":"Contributing"},{"location":"concepts/vault_plugins/","text":"HashiCorp Vault plugins HashiCorp Vault plugins are standalone applications that Vault server executes to enable third-party secret engines and auth methods. After their enablement during Vault server initialization, the plugins can be used as a regular auth or secrets backends. This project uses secrets plugins to retrieve dataset credentials by the running modules . The plugins retrieve the credentials from where they are stored, for example, data catalog or in kubernetes secret. Vault-plugin-secrets-kubernetes-reader plugin is an example of Vault custom secret plugin which retrieves dataset credentials stored in a kubernetes secret. Additional secret plugins can be developed to retrieve credentials additional location. This tutorial can serve as a good starting point to learn about Vault plugin development. The following steps are for configuring a secret plug-in for Fybrik: Enable the plugin during Vault server initialization in a specific path. An example of that can be found in helm chart values.yaml file in the project where Vault-plugin-secrets-kubernetes-reader plugin is enabled in kubernetes-secrets path: vault secrets enable -path = kubernetes-secrets vault-plugin-secrets-kubernetes-reader Add Vault policy to allow the modules to access secrets using the plugin. Following is an example of a policy which gives permission to read secrets in Vault path kubernetes-secrets : vault policy write \"allow-all-dataset-creds\" - <<EOF path \"kubernetes-secrets/*\" { capabilities = [\"read\"] } EOF Have the CatalogDatasetInfo structure from the data catalog response contain the Vault secret path which should be used to retrieve the credentials for a given asset. When Vault plugin is used to retrieve the credentials the parameters to the plugin should follow the plugin usage instructions. This path will later be passed on to the modules . For example, when the credentials are stored in kubernetes secret as is done in the Katalog built-in data catalog; the Vault-plugin-secrets-kubernetes-reader plugin can be used to retrieve the credentials. In this case two parameters should be passed: paysim-csv which is the kubernetes secret name that holds the credentials and fybrik-notebook-sample is the secret namespace, both are known to the katalog when constructing the path. The following snippet shows CatalogDatasetInfo structure with Vault secret path in CredentialsInfo field. connectors.CatalogDatasetInfo { DatasetId: fybrik-notebook-sample/paysim-csv, Details: & connectors.DatasetDetails { Name: fybrik-notebook-sample/paysim-csv, Geo: theshire, DataStore: fybrik-notebook-sample/paysim-csv, CredentialsInfo: & connectors.CredentialsInfo { VaultSecretPath: \"/v1/kubernetes-secrets/paysim-csv?namespace=fybrik-notebook-sample\" } , } , } Update the modules to use the Vault related values to retrieve dataset credentias during their runtime execution. The values contain secretPath field with the plugin path as described in the previous step. The following snippet, taken from hello-world-module values.yaml file, contains an example of such values. vault: # Address is Vault address address: http://vault.fybrik-system:8200 # AuthPath is the path to auth method used to login to Vault authPath: /v1/auth/kubernetes/login # Role is the Vault role used for retrieving the credentials role: module # SecretPath is the path of the secret holding the Credentials in Vault secretPath: /v1/kubernetes-secrets/paysim-csv?namespace = fybrik-notebook-sample","title":"HashiCorp Vault plugins"},{"location":"concepts/vault_plugins/#hashicorp-vault-plugins","text":"HashiCorp Vault plugins are standalone applications that Vault server executes to enable third-party secret engines and auth methods. After their enablement during Vault server initialization, the plugins can be used as a regular auth or secrets backends. This project uses secrets plugins to retrieve dataset credentials by the running modules . The plugins retrieve the credentials from where they are stored, for example, data catalog or in kubernetes secret. Vault-plugin-secrets-kubernetes-reader plugin is an example of Vault custom secret plugin which retrieves dataset credentials stored in a kubernetes secret. Additional secret plugins can be developed to retrieve credentials additional location. This tutorial can serve as a good starting point to learn about Vault plugin development. The following steps are for configuring a secret plug-in for Fybrik: Enable the plugin during Vault server initialization in a specific path. An example of that can be found in helm chart values.yaml file in the project where Vault-plugin-secrets-kubernetes-reader plugin is enabled in kubernetes-secrets path: vault secrets enable -path = kubernetes-secrets vault-plugin-secrets-kubernetes-reader Add Vault policy to allow the modules to access secrets using the plugin. Following is an example of a policy which gives permission to read secrets in Vault path kubernetes-secrets : vault policy write \"allow-all-dataset-creds\" - <<EOF path \"kubernetes-secrets/*\" { capabilities = [\"read\"] } EOF Have the CatalogDatasetInfo structure from the data catalog response contain the Vault secret path which should be used to retrieve the credentials for a given asset. When Vault plugin is used to retrieve the credentials the parameters to the plugin should follow the plugin usage instructions. This path will later be passed on to the modules . For example, when the credentials are stored in kubernetes secret as is done in the Katalog built-in data catalog; the Vault-plugin-secrets-kubernetes-reader plugin can be used to retrieve the credentials. In this case two parameters should be passed: paysim-csv which is the kubernetes secret name that holds the credentials and fybrik-notebook-sample is the secret namespace, both are known to the katalog when constructing the path. The following snippet shows CatalogDatasetInfo structure with Vault secret path in CredentialsInfo field. connectors.CatalogDatasetInfo { DatasetId: fybrik-notebook-sample/paysim-csv, Details: & connectors.DatasetDetails { Name: fybrik-notebook-sample/paysim-csv, Geo: theshire, DataStore: fybrik-notebook-sample/paysim-csv, CredentialsInfo: & connectors.CredentialsInfo { VaultSecretPath: \"/v1/kubernetes-secrets/paysim-csv?namespace=fybrik-notebook-sample\" } , } , } Update the modules to use the Vault related values to retrieve dataset credentias during their runtime execution. The values contain secretPath field with the plugin path as described in the previous step. The following snippet, taken from hello-world-module values.yaml file, contains an example of such values. vault: # Address is Vault address address: http://vault.fybrik-system:8200 # AuthPath is the path to auth method used to login to Vault authPath: /v1/auth/kubernetes/login # Role is the Vault role used for retrieving the credentials role: module # SecretPath is the path of the secret holding the Credentials in Vault secretPath: /v1/kubernetes-secrets/paysim-csv?namespace = fybrik-notebook-sample","title":"HashiCorp Vault plugins"},{"location":"contribute/","text":"Contribute Fybrik is open for contributions and welcomes anyone who wishes to contribute and take part in our journey towards success. This section contains information and guidelines to help you contribute more easily to the project. We would love for you to get involved Join our community in GitHub Discussions","title":"About"},{"location":"contribute/#contribute","text":"Fybrik is open for contributions and welcomes anyone who wishes to contribute and take part in our journey towards success. This section contains information and guidelines to help you contribute more easily to the project. We would love for you to get involved Join our community in GitHub Discussions","title":"Contribute"},{"location":"contribute/build-test/","text":"Build and Test Build the project images make docker-build Run unit tests make test Some tests for controllers are written in a fashion that they can be run on a simulated environment using envtest or on an already existing Kubernetes cluster (or local kind cluster). The default is to use envtest. In order to run the tests in a local cluster the following environment variables can be set: NO_SIMULATED_PROGRESS = true USE_EXISTING_CLUSTER = true make -C manager test Please be aware that the controller is running locally in this case! If a controller is already deployed onto the cluster then the tests can be run with the command below. This will ensure that the tests are only creating CRDs on the cluster and checking their status: USE_EXISTING_CONTROLLER = true NO_SIMULATED_PROGRESS = true USE_EXISTING_CLUSTER = true make -C manager test Environment variables description Environment variable Default Description USE_EXISTING_CLUSTER false This variable controls if an existing K8s cluster should be used or not. If not envtest will spin up an artificial environment that includes a local etcd setup. NO_SIMULATED_PROGRESS false This variable can be used by tests that can manually simulate progress of e.g. jobs or pods. e.g. the simulated test environment from testEnv does not progress pods etc while when testing against an external Kubernetes cluster this will actually run pods. USE_EXISTING_CONTROLLER false This variable controls if a controller should be set up and run by this test suite or if an external one should be used. E.g. in integration tests running against an existing setup a controller is already existing in the Kubernetes cluster and should not be started by the test as two controllers competing may influence the test. Running integration tests With the following you will then setup a kind cluster with the local registry, build and push current docker images and finally run the integration tests on it: make run-integration-tests It is sometimes useful to call the integration test commands step by step, e.g., if you want to only repeat a specific step which failed without having to rerun the entire sequence. You can find the commands of the run-integration-tests target in the Makefile . You can run make kind-cleanup to delete the created clusters when you're done. Building in a multi cluster environment As Fybrik can run in a multi-cluster environment there is also a test environment that can be used that simulates this scenario. Using kind one can spin up two separate kubernetes clusters with different contexts and develop and test in these. Two kind clusters that share the same kind-registry can be set up using: make kind-setup-multi You can run make kind-cleanup to delete the created clusters when you're done.","title":"Build and Test"},{"location":"contribute/build-test/#build-and-test","text":"","title":"Build and Test"},{"location":"contribute/build-test/#build-the-project-images","text":"make docker-build","title":"Build the project images"},{"location":"contribute/build-test/#run-unit-tests","text":"make test Some tests for controllers are written in a fashion that they can be run on a simulated environment using envtest or on an already existing Kubernetes cluster (or local kind cluster). The default is to use envtest. In order to run the tests in a local cluster the following environment variables can be set: NO_SIMULATED_PROGRESS = true USE_EXISTING_CLUSTER = true make -C manager test Please be aware that the controller is running locally in this case! If a controller is already deployed onto the cluster then the tests can be run with the command below. This will ensure that the tests are only creating CRDs on the cluster and checking their status: USE_EXISTING_CONTROLLER = true NO_SIMULATED_PROGRESS = true USE_EXISTING_CLUSTER = true make -C manager test","title":"Run unit tests"},{"location":"contribute/build-test/#environment-variables-description","text":"Environment variable Default Description USE_EXISTING_CLUSTER false This variable controls if an existing K8s cluster should be used or not. If not envtest will spin up an artificial environment that includes a local etcd setup. NO_SIMULATED_PROGRESS false This variable can be used by tests that can manually simulate progress of e.g. jobs or pods. e.g. the simulated test environment from testEnv does not progress pods etc while when testing against an external Kubernetes cluster this will actually run pods. USE_EXISTING_CONTROLLER false This variable controls if a controller should be set up and run by this test suite or if an external one should be used. E.g. in integration tests running against an existing setup a controller is already existing in the Kubernetes cluster and should not be started by the test as two controllers competing may influence the test.","title":"Environment variables description"},{"location":"contribute/build-test/#running-integration-tests","text":"With the following you will then setup a kind cluster with the local registry, build and push current docker images and finally run the integration tests on it: make run-integration-tests It is sometimes useful to call the integration test commands step by step, e.g., if you want to only repeat a specific step which failed without having to rerun the entire sequence. You can find the commands of the run-integration-tests target in the Makefile . You can run make kind-cleanup to delete the created clusters when you're done.","title":"Running integration tests"},{"location":"contribute/build-test/#building-in-a-multi-cluster-environment","text":"As Fybrik can run in a multi-cluster environment there is also a test environment that can be used that simulates this scenario. Using kind one can spin up two separate kubernetes clusters with different contexts and develop and test in these. Two kind clusters that share the same kind-registry can be set up using: make kind-setup-multi You can run make kind-cleanup to delete the created clusters when you're done.","title":"Building in a multi cluster environment"},{"location":"contribute/environment/","text":"Development Environment This page describes what you need to install as a developer and contributor to this project, for setting up a development environment. Operating system Linux and Mac OS operating systems are officially supported. Windows users should consider using Windows Subsystem for Linux 2 (WSL 2), a remote Linux machine, or any other solution such as a virtual machine. Dependencies Install the following on your machine: go 1.16 or above Docker make jq unzip Maven ( mvn ) Java Development Kit version 8 or above Mac only : brew install coreutils (installs the timeout command) Then, run the following command to install additional dependencies: make install-tools This installs additional dependencies to hack/tools/bin . The make targets (e.g., make test ) are configured to use the binaries from hack/tools/bin . However, you may want to add some of these tools to your system PATH for direct usage from your terminal (e.g., for using kubectl ). Please note: For fybrik version 0.5 and lower, Helm version greater than 3.3 but less than 3.7 is required when contributing. Editors The project is predominantly written in Go, so we recommend Visual Studio Code for its good Go support. Alternatively you can select from Editors Docker hub rate limits As docker hub introduced rate limits on docker image downloads this may affect development using the local kind setup. One option to fix the limit is to use a docker hub login for downloading the images. The environment will run a docker registry as a proxy for all public images. This registry runs in a docker container next to the kind clusters. export DOCKERHUB_USERNAME = 'your docker hub username' export DOCKERHUB_PASSWORD = 'your password'","title":"Development Environment"},{"location":"contribute/environment/#development-environment","text":"This page describes what you need to install as a developer and contributor to this project, for setting up a development environment.","title":"Development Environment"},{"location":"contribute/environment/#operating-system","text":"Linux and Mac OS operating systems are officially supported. Windows users should consider using Windows Subsystem for Linux 2 (WSL 2), a remote Linux machine, or any other solution such as a virtual machine.","title":"Operating system"},{"location":"contribute/environment/#dependencies","text":"Install the following on your machine: go 1.16 or above Docker make jq unzip Maven ( mvn ) Java Development Kit version 8 or above Mac only : brew install coreutils (installs the timeout command) Then, run the following command to install additional dependencies: make install-tools This installs additional dependencies to hack/tools/bin . The make targets (e.g., make test ) are configured to use the binaries from hack/tools/bin . However, you may want to add some of these tools to your system PATH for direct usage from your terminal (e.g., for using kubectl ). Please note: For fybrik version 0.5 and lower, Helm version greater than 3.3 but less than 3.7 is required when contributing.","title":"Dependencies"},{"location":"contribute/environment/#editors","text":"The project is predominantly written in Go, so we recommend Visual Studio Code for its good Go support. Alternatively you can select from Editors","title":"Editors"},{"location":"contribute/environment/#docker-hub-rate-limits","text":"As docker hub introduced rate limits on docker image downloads this may affect development using the local kind setup. One option to fix the limit is to use a docker hub login for downloading the images. The environment will run a docker registry as a proxy for all public images. This registry runs in a docker container next to the kind clusters. export DOCKERHUB_USERNAME = 'your docker hub username' export DOCKERHUB_PASSWORD = 'your password'","title":"Docker hub rate limits"},{"location":"contribute/flow/","text":"GitHub Workflow This page describes the GitHub workflow that contributors should follow. Issues and pull requests Contributing to Fybrik is done following the GitHub workflow of Pull Requests. You should usually open a pull request in the following situations: Start work on a contribution that was that you\u2019ve already discussed in an issue. Submit trivial fixes (for example, a typo, a broken link or an obvious error). A pull request doesn\u2019t have to represent finished work. It\u2019s usually better to open a draft pull request early on, so others can watch or give feedback on your progress. Here\u2019s how to submit a pull request: Fork the main repository Clone the forked repository locally . Connect your local to the original \u201cupstream\u201d repository by adding it as a remote. git clone git@github.com: $( git config user.name ) /fybrik.git git remote add upstream https://github.com/fybrik/fybrik.git git remote set-url --push upstream no_push Pull in changes from \u201cupstream\u201d often so that you stay up to date so that when you submit your pull request, merge conflicts will be less likely. git fetch upstream master git checkout master git merge upstream/master git push origin master Create a branch for your edits from master. Note that you should never add edits to the master branch itself. git checkout -b <branch name> Make commits of logical units , ensuring that commit messages are in the proper format . Push your changes to the created branch in your fork of the repository. Open a pull request to the original repository. Reference any relevant issues or supporting documentation in your PR (for example, \u201cCloses #37.\u201d) As always, you must follow code style , ensure that all tests pass , and add any new tests as appropriate. Thanks for your contribution! Normalize the code To ensure the code is formatted uniformly we use various linters which are invoked using make verify Format of the Commit Message The project follows a rough convention for commit messages that is designed to answer two questions: what changed and why. The subject line should feature the what and the body of the commit should describe the why. Every commit must also include a DCO Sign Off at the end of the commit message. By doing this you state that you certify the Developer Certificate of Origin . This can be automated by adding the -s flag to git commit . You can also mass sign-off a whole PR with git rebase --signoff master . Example commit message: scripts: add the test-cluster command this uses tmux to setup a test cluster that you can easily kill and start for debugging. Fixes #38 Signed-off-by: Legal Name <your.email@example.com> The format can be described more formally as follows: <subsystem>: <what changed> <BLANK LINE> <why this change was made> <BLANK LINE> <footer> <BLANK LINE> <signoff> The first line is the subject and should be no longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters. This allows the message to be easier to read on GitHub as well as in various git tools.","title":"GitHub Workflow"},{"location":"contribute/flow/#github-workflow","text":"This page describes the GitHub workflow that contributors should follow.","title":"GitHub Workflow"},{"location":"contribute/flow/#issues-and-pull-requests","text":"Contributing to Fybrik is done following the GitHub workflow of Pull Requests. You should usually open a pull request in the following situations: Start work on a contribution that was that you\u2019ve already discussed in an issue. Submit trivial fixes (for example, a typo, a broken link or an obvious error). A pull request doesn\u2019t have to represent finished work. It\u2019s usually better to open a draft pull request early on, so others can watch or give feedback on your progress. Here\u2019s how to submit a pull request: Fork the main repository Clone the forked repository locally . Connect your local to the original \u201cupstream\u201d repository by adding it as a remote. git clone git@github.com: $( git config user.name ) /fybrik.git git remote add upstream https://github.com/fybrik/fybrik.git git remote set-url --push upstream no_push Pull in changes from \u201cupstream\u201d often so that you stay up to date so that when you submit your pull request, merge conflicts will be less likely. git fetch upstream master git checkout master git merge upstream/master git push origin master Create a branch for your edits from master. Note that you should never add edits to the master branch itself. git checkout -b <branch name> Make commits of logical units , ensuring that commit messages are in the proper format . Push your changes to the created branch in your fork of the repository. Open a pull request to the original repository. Reference any relevant issues or supporting documentation in your PR (for example, \u201cCloses #37.\u201d) As always, you must follow code style , ensure that all tests pass , and add any new tests as appropriate. Thanks for your contribution!","title":"Issues and pull requests"},{"location":"contribute/flow/#normalize-the-code","text":"To ensure the code is formatted uniformly we use various linters which are invoked using make verify","title":"Normalize the code"},{"location":"contribute/flow/#format-of-the-commit-message","text":"The project follows a rough convention for commit messages that is designed to answer two questions: what changed and why. The subject line should feature the what and the body of the commit should describe the why. Every commit must also include a DCO Sign Off at the end of the commit message. By doing this you state that you certify the Developer Certificate of Origin . This can be automated by adding the -s flag to git commit . You can also mass sign-off a whole PR with git rebase --signoff master . Example commit message: scripts: add the test-cluster command this uses tmux to setup a test cluster that you can easily kill and start for debugging. Fixes #38 Signed-off-by: Legal Name <your.email@example.com> The format can be described more formally as follows: <subsystem>: <what changed> <BLANK LINE> <why this change was made> <BLANK LINE> <footer> <BLANK LINE> <signoff> The first line is the subject and should be no longer than 70 characters, the second line is always blank, and other lines should be wrapped at 80 characters. This allows the message to be easier to read on GitHub as well as in various git tools.","title":"Format of the Commit Message"},{"location":"contribute/logging/","text":"Logging This page describes the information that your code should provide in all log entries it generates, and some tools fybrik provides to ensure consistency across components. Background Log entries should be written to stdout and stderr. Fybrik does not collect nor aggregate logs. This may be done by external tools. (ex: logstash, fluentd, etc.) A globally unique identifier for each FybrikApplication instance is passed to all control plane and data plane components to be included in log entries. This enables corrrelation of log entries across different logs and clusters for the specific instance, even if the name of the FybrikApplication is reused over time. Log Entry Contents All fybrik components, whether control plane or data plane components, should write log entries to stdout and stderr in json format. The contents of the log entries are detailed in fybrik.io/pkg/logging/logging.go. The fybrik control plane uses zerolog for its golang components, and provides a library of fybrik specific helper functions to be used with it. Examples of how to use zerolog: https://github.com/rs/zerolog/blob/master/log_example_test.go TBD - fybrik logging helper functions for python and java. Log Entry Verbosity Log levels should be used as follows: panic (zerolog.PanicLevel, 5) - Errors that prevent the component from operating correctly and handling requests Ex: fybrik control plane did not deploy correctly Ex: Data plane component crashed and cannot handle requests fatal (zerolog.FatalLevel, 4) - Errors that prevent the component from successfully completing a particular task Ex: fybrikapplication controller cannot generate a plotter Ex: Arrow/Flight server used to read data cannot access data store error (zerolog.ErrorLevel, 3) - Errors that are not fatal nor panic, but that the user / request initiator is made aware of (typical production setting for stable solution) Ex: Dataset requested in fybrikapplication.spec is not allowed to be used Ex: Query to Arrow/Flight server used to read data returns an error because of incorrect dataset ID warn (zerolog.WarnLevel, 2) - Errors not shared with the user / request initiator, typically from which the component recovers on its own info (zerolog.InfoLevel, 1) - High level health information that makes it clear the overall status, but without much detail (highest level used in production) debug (zerolog.DebugLevel, 0) - Additional information needed to help identify problems (typically used during testing) trace (zerolog.TraceLevel, -1) - For tracing step by step flow of control (typically used during development) Environment Variables LOGGING_VERBOSITY - should be set to one of the levels described in the previous section. PRETTY_LOGGING - If true log entries are in human readable format. If false, they are in json. Should only be true during individual development, since json is preferred to enable easy parsing by aggregator tools.","title":"Logging"},{"location":"contribute/logging/#logging","text":"This page describes the information that your code should provide in all log entries it generates, and some tools fybrik provides to ensure consistency across components.","title":"Logging"},{"location":"contribute/logging/#background","text":"Log entries should be written to stdout and stderr. Fybrik does not collect nor aggregate logs. This may be done by external tools. (ex: logstash, fluentd, etc.) A globally unique identifier for each FybrikApplication instance is passed to all control plane and data plane components to be included in log entries. This enables corrrelation of log entries across different logs and clusters for the specific instance, even if the name of the FybrikApplication is reused over time.","title":"Background"},{"location":"contribute/logging/#log-entry-contents","text":"All fybrik components, whether control plane or data plane components, should write log entries to stdout and stderr in json format. The contents of the log entries are detailed in fybrik.io/pkg/logging/logging.go. The fybrik control plane uses zerolog for its golang components, and provides a library of fybrik specific helper functions to be used with it. Examples of how to use zerolog: https://github.com/rs/zerolog/blob/master/log_example_test.go TBD - fybrik logging helper functions for python and java.","title":"Log Entry Contents"},{"location":"contribute/logging/#log-entry-verbosity","text":"Log levels should be used as follows: panic (zerolog.PanicLevel, 5) - Errors that prevent the component from operating correctly and handling requests Ex: fybrik control plane did not deploy correctly Ex: Data plane component crashed and cannot handle requests fatal (zerolog.FatalLevel, 4) - Errors that prevent the component from successfully completing a particular task Ex: fybrikapplication controller cannot generate a plotter Ex: Arrow/Flight server used to read data cannot access data store error (zerolog.ErrorLevel, 3) - Errors that are not fatal nor panic, but that the user / request initiator is made aware of (typical production setting for stable solution) Ex: Dataset requested in fybrikapplication.spec is not allowed to be used Ex: Query to Arrow/Flight server used to read data returns an error because of incorrect dataset ID warn (zerolog.WarnLevel, 2) - Errors not shared with the user / request initiator, typically from which the component recovers on its own info (zerolog.InfoLevel, 1) - High level health information that makes it clear the overall status, but without much detail (highest level used in production) debug (zerolog.DebugLevel, 0) - Additional information needed to help identify problems (typically used during testing) trace (zerolog.TraceLevel, -1) - For tracing step by step flow of control (typically used during development)","title":"Log Entry Verbosity"},{"location":"contribute/logging/#environment-variables","text":"LOGGING_VERBOSITY - should be set to one of the levels described in the previous section. PRETTY_LOGGING - If true log entries are in human readable format. If false, they are in json. Should only be true during individual development, since json is preferred to enable easy parsing by aggregator tools.","title":"Environment Variables"},{"location":"contribute/modules/","text":"Module Development This page describes what must be provided when contributing a module . Steps for creating a module Implement the logic of the module you are contributing. The implementation can either be directly in the Module Workload or in an external component. If the logic is in an external component, then the module workload should act as a client - i.e. receiving paramaters from the control plane and passing them to the external component. Create and publish the Module Helm Chart that will be used by the control plane to deploy the module workload, update it, and delete it as necessary. Create the FybrikModule YAML which describes the capabilities of the module workload, in which flows it should be considered for inclusion, its supported interfaces, and the link to the module helm chart. Test the new module These steps are described in the following sections in more detail, so that you can create your own modules for use by Fybrik. Note that a new module is maintained in its own git repository, separate from the fybrik repository. Module Workload The module workload is associated with a specific user workload and is deployed by the control plane. It may implement the logic required itself, or it may be a client interface to an external component. The former will have module type \"server\" and the latter \"config\". There is also a third type of module workload known as a plugin. It provides a standard interface by which another module may invoke its capabilities. For example, you may have a module that reads data but doesn't know how to do data transforms. Rather than implementing transforms in the module workload code, it can call the plugin to do the transforms. The control plane deploys the relevant transform plugin as well as the read module. Credential management Modules that access or write data need credentials in order to access the data store. The credentials are retrieved from HashiCorp Vault . The parameters to login to vault and to read secret are passed as part of the arguments to the module Helm chart. An example for Vault Login API call which uses the Vault parameters is as follows: $ curl -v -X POST <address>/<authPath> -H \"Content-Type: application/json\" --data '{\"jwt\": <module service account token>, \"role\": <role>}' An example for Vault Read Secret API call which uses the Vault parameters is as follows: $ curl --header \"X-Vault-Token: ...\" -X GET https://<address>/<secretPath> Module Helm Chart For any module chosen by the control plane to be part of the data path, the control plane needs to be able to install/remove/upgrade an instance of the module. Fybrik uses Helm to provide this functionality. Follow the Helm getting started guide if you are unfamiliar with Helm. Note that Helm 3.7 or above is required. The names of the Kubernetes resources deployed by the module helm chart must contain the release name to avoid resource conflicts. A Kubernetes service resource which is used to access the module must have a name equal to the release name (this service name is also used in the optional spec.capabilities.api.endpoint.hostname field). Because the chart is installed by the control plane, the input values to the chart must match the relevant type of arguments . If the module workload needs to return information to the user, that information should be written to the NOTES.txt of the helm chart. For a full example see the Arrow Flight Module chart . Publishing the Helm Chart Once your Helm chart is ready, you need to push it to a OCI-based registry such as ghcr.io . This allows the control plane of Fybrik to later pull the chart whenever it needs to be installed. You can use the hack/make-rules/helm.mk Makefile, or manually push the chart as described in the link : HELM_EXPERIMENTAL_OCI = 1 helm registry login -u <username> <registry> helm package <chart folder> -d <local-chart-path> helm push <local-chart-path> oci://<registry>/<path> FybrikModule YAML FybrikModule is a kubernetes Custom Resource Definition (CRD) which describes to the control plane the functionality provided by the module. The FybrikModule CRD has no controller. The specification of the FybrikModule Kubernetes CRD is available in the API documentation . The YAML file begins with standard Kubernetes metadata followed by the FybrikModule specification: apiVersion : app.fybrik.io/v1alpha1 # always this value kind : FybrikModule # always this value metadata : name : \"<module name>\" # the name of your new module labels : name : \"<module name>\" # the name of your new module version : \"<semantic version>\" namespace : fybrik-system # control plane namespace. Always fybrik-system spec : ... The child fields of spec are described next. spec.chart This is a link to a the Helm chart stored in the image registry . This is similar to how a Kubernetes Pod references a container image. See Module Helm chart for more details. spec: chart: name: \"<helm chart link>\" # e.g.: ghcr.io/username/chartname:chartversion values: image.tag: v0.0.1 spec.statusIndicators Used for tracking the status of the module in terms of success or failure. In many cases this can be omitted and the status will be detected automatically. if the Helm chart includes standard Kubernetes resources such as Deployment and Service, then the status is automatically detected. If however Custom Resource Definitions are used, then the status may not be automatically detected and statusIndicators should be specified. statusIndicators : - kind : \"<module name>\" successCondition : \"<condition>\" # ex: status.status == SUCCEEDED failureCondition : \"<condition>\" # ex: status.status == FAILED errorMessage : \"<field path>\" # ex: status.error spec.dependencies A dependency has a type and a name . Currently dependencies of type module are supported, indicating that another module must also be installed for this module to work. dependencies : - type : module #currently the only option is a dependency on another module deployed by the control plane name : <dependent module name> spec.type The type field may be one of the following vaues: 1)service - Indicates that module workload implements the modules logic, and is deployed by the fybrik control plane. 2) config - In this case the logic is performed by a component deployed externally, i.e. not by the fybrik control plane. Such components can be assumed to support multiple workloads. 3) plugin (FUTURE) - This type of module enables a sub-set of often used capabilities to be implemented once and re-used by any module that supports plugins of the declared type. spec.pluginType (Future Functionality) The types of plugins supported by this module. Example: vault, fybrik-wasm ... spec.capabilities Each module may support one or more capabilities. Currently there are four capabilities: read for enabling an application to read data or prepare data for being read, write for enabling an application to write data, and copy for performing an implicit data copy on behalf of the application, and transform for altering data based on governance policies. A module provides one or more of these capabilities. capabilities.capability Indicates which of the types of capabilities this instance describes. capability : # Indicate the capabilities for which the control plane should consider using this module - read # optional - write # optional - copy # optional - transform # optional capability.scope The capability provided by the module may work on one of several different scopes: workload - deployed once by fybrik and available for use by the data planes of all the datasets asset - deployed by fybrik for each dataset cluster - deployed outside of fybrik and can be used by multiple fybbrik workloads in a given cluster scope : <scope of the capability> # cluster, workload, asset capabilites.supportedInterfaces Lists the supported data services from which the module can read data (sources) and to which it can write (sinks). There can be multiple sources and sinks. For each, a protocol and format are provided. protocol field can take a value such as kafka , s3 , db2 , fybrik-arrow-flight , etc. format field can take a value such as avro , parquet , json , or csv . Note that a module that targets copy flows will omit the api field and contain just source and sink , a module that only supports reading data assets will omit the sink field and only contain api and source capabilites.api describes the api exposed by the module to the user's workload for the particular capability. protocol field can take a value such as kafka , s3 , db2 , fybrik-arrow-flight , etc dataformat field can take a value such as parquet , csv , avro , etc endpoint field describes the endpoint exposed the module capabilites.api.endpoint describes the endpoint from a networking perspective: hostname field is the hostname to be used when accessing the module. Equals the release name. Can be omitted. port field is the port of the service exposed by the module. scheme field can take a value such as http , https , grpc , grpc+tls , jdbc:oracle:thin:@ , etc An example for a module that copies data from a db2 database table to an s3 bucket in parquet format. capabilities : - capability : copy supportedInterfaces : - source : protocol : db2 sink : protocol : s3 dataformat : parquet An example for a module that has an API for reading data, and supports reading both parquet and csv formats from s3. capabilities : - capability : read api : protocol : fybrik-arrow-flight endpoint : port : 80 scheme : grpc supportedInterfaces : - source : protocol : s3 dataformat : parquet - flow : read source : protocol : s3 dataformat : csv capabilites.actions are taken from a defined Enforcement Actions Taxonomy a module that does not perform any transformation on the data may omit the capabilities.actions field. The following is an example of how a module would declare that it knows how to redact, remove or encrypt data. Additional properties may be associated with each action. capabilities : - read : actions : - name : \"RedactAction\" - name : \"RemoveAction\" - name : \"EncryptAction\" Full Examples The following are examples of YAMLs from fully implemented modules: An example YAML for a module that copies from db2 to s3 and includes transformation actions And an example arrow flight read module YAML, also with transformation support Getting Started In order to help module developers get started there are two example \"hello world\" modules: * Hello world module * Hellow world read module An example of a fully functional module is the [arrow flight module][https://github.com/fybrik/arrow-flight-module] Test Register the module to make the control plane aware of it. Create an FybrikApplication YAML for a user workload, ensuring that the data set and other parameters included in it, together with the governance policies defined in the policy manager, will result in your module being chosen based on the control plane logic . Apply the FybrikApplication YAML. View the FybrikApplication status . Run the user workload and review the results to check if they are what is expected.","title":"Module Development"},{"location":"contribute/modules/#module-development","text":"This page describes what must be provided when contributing a module .","title":"Module Development"},{"location":"contribute/modules/#steps-for-creating-a-module","text":"Implement the logic of the module you are contributing. The implementation can either be directly in the Module Workload or in an external component. If the logic is in an external component, then the module workload should act as a client - i.e. receiving paramaters from the control plane and passing them to the external component. Create and publish the Module Helm Chart that will be used by the control plane to deploy the module workload, update it, and delete it as necessary. Create the FybrikModule YAML which describes the capabilities of the module workload, in which flows it should be considered for inclusion, its supported interfaces, and the link to the module helm chart. Test the new module These steps are described in the following sections in more detail, so that you can create your own modules for use by Fybrik. Note that a new module is maintained in its own git repository, separate from the fybrik repository.","title":"Steps for creating a module"},{"location":"contribute/modules/#module-workload","text":"The module workload is associated with a specific user workload and is deployed by the control plane. It may implement the logic required itself, or it may be a client interface to an external component. The former will have module type \"server\" and the latter \"config\". There is also a third type of module workload known as a plugin. It provides a standard interface by which another module may invoke its capabilities. For example, you may have a module that reads data but doesn't know how to do data transforms. Rather than implementing transforms in the module workload code, it can call the plugin to do the transforms. The control plane deploys the relevant transform plugin as well as the read module.","title":"Module Workload"},{"location":"contribute/modules/#credential-management","text":"Modules that access or write data need credentials in order to access the data store. The credentials are retrieved from HashiCorp Vault . The parameters to login to vault and to read secret are passed as part of the arguments to the module Helm chart. An example for Vault Login API call which uses the Vault parameters is as follows: $ curl -v -X POST <address>/<authPath> -H \"Content-Type: application/json\" --data '{\"jwt\": <module service account token>, \"role\": <role>}' An example for Vault Read Secret API call which uses the Vault parameters is as follows: $ curl --header \"X-Vault-Token: ...\" -X GET https://<address>/<secretPath>","title":"Credential management"},{"location":"contribute/modules/#module-helm-chart","text":"For any module chosen by the control plane to be part of the data path, the control plane needs to be able to install/remove/upgrade an instance of the module. Fybrik uses Helm to provide this functionality. Follow the Helm getting started guide if you are unfamiliar with Helm. Note that Helm 3.7 or above is required. The names of the Kubernetes resources deployed by the module helm chart must contain the release name to avoid resource conflicts. A Kubernetes service resource which is used to access the module must have a name equal to the release name (this service name is also used in the optional spec.capabilities.api.endpoint.hostname field). Because the chart is installed by the control plane, the input values to the chart must match the relevant type of arguments . If the module workload needs to return information to the user, that information should be written to the NOTES.txt of the helm chart. For a full example see the Arrow Flight Module chart .","title":"Module Helm Chart"},{"location":"contribute/modules/#publishing-the-helm-chart","text":"Once your Helm chart is ready, you need to push it to a OCI-based registry such as ghcr.io . This allows the control plane of Fybrik to later pull the chart whenever it needs to be installed. You can use the hack/make-rules/helm.mk Makefile, or manually push the chart as described in the link : HELM_EXPERIMENTAL_OCI = 1 helm registry login -u <username> <registry> helm package <chart folder> -d <local-chart-path> helm push <local-chart-path> oci://<registry>/<path>","title":"Publishing the Helm Chart"},{"location":"contribute/modules/#fybrikmodule-yaml","text":"FybrikModule is a kubernetes Custom Resource Definition (CRD) which describes to the control plane the functionality provided by the module. The FybrikModule CRD has no controller. The specification of the FybrikModule Kubernetes CRD is available in the API documentation . The YAML file begins with standard Kubernetes metadata followed by the FybrikModule specification: apiVersion : app.fybrik.io/v1alpha1 # always this value kind : FybrikModule # always this value metadata : name : \"<module name>\" # the name of your new module labels : name : \"<module name>\" # the name of your new module version : \"<semantic version>\" namespace : fybrik-system # control plane namespace. Always fybrik-system spec : ... The child fields of spec are described next.","title":"FybrikModule YAML"},{"location":"contribute/modules/#specchart","text":"This is a link to a the Helm chart stored in the image registry . This is similar to how a Kubernetes Pod references a container image. See Module Helm chart for more details. spec: chart: name: \"<helm chart link>\" # e.g.: ghcr.io/username/chartname:chartversion values: image.tag: v0.0.1","title":"spec.chart"},{"location":"contribute/modules/#specstatusindicators","text":"Used for tracking the status of the module in terms of success or failure. In many cases this can be omitted and the status will be detected automatically. if the Helm chart includes standard Kubernetes resources such as Deployment and Service, then the status is automatically detected. If however Custom Resource Definitions are used, then the status may not be automatically detected and statusIndicators should be specified. statusIndicators : - kind : \"<module name>\" successCondition : \"<condition>\" # ex: status.status == SUCCEEDED failureCondition : \"<condition>\" # ex: status.status == FAILED errorMessage : \"<field path>\" # ex: status.error","title":"spec.statusIndicators"},{"location":"contribute/modules/#specdependencies","text":"A dependency has a type and a name . Currently dependencies of type module are supported, indicating that another module must also be installed for this module to work. dependencies : - type : module #currently the only option is a dependency on another module deployed by the control plane name : <dependent module name>","title":"spec.dependencies"},{"location":"contribute/modules/#spectype","text":"The type field may be one of the following vaues: 1)service - Indicates that module workload implements the modules logic, and is deployed by the fybrik control plane. 2) config - In this case the logic is performed by a component deployed externally, i.e. not by the fybrik control plane. Such components can be assumed to support multiple workloads. 3) plugin (FUTURE) - This type of module enables a sub-set of often used capabilities to be implemented once and re-used by any module that supports plugins of the declared type.","title":"spec.type"},{"location":"contribute/modules/#specplugintype","text":"(Future Functionality) The types of plugins supported by this module. Example: vault, fybrik-wasm ...","title":"spec.pluginType"},{"location":"contribute/modules/#speccapabilities","text":"Each module may support one or more capabilities. Currently there are four capabilities: read for enabling an application to read data or prepare data for being read, write for enabling an application to write data, and copy for performing an implicit data copy on behalf of the application, and transform for altering data based on governance policies. A module provides one or more of these capabilities. capabilities.capability Indicates which of the types of capabilities this instance describes. capability : # Indicate the capabilities for which the control plane should consider using this module - read # optional - write # optional - copy # optional - transform # optional capability.scope The capability provided by the module may work on one of several different scopes: workload - deployed once by fybrik and available for use by the data planes of all the datasets asset - deployed by fybrik for each dataset cluster - deployed outside of fybrik and can be used by multiple fybbrik workloads in a given cluster scope : <scope of the capability> # cluster, workload, asset capabilites.supportedInterfaces Lists the supported data services from which the module can read data (sources) and to which it can write (sinks). There can be multiple sources and sinks. For each, a protocol and format are provided. protocol field can take a value such as kafka , s3 , db2 , fybrik-arrow-flight , etc. format field can take a value such as avro , parquet , json , or csv . Note that a module that targets copy flows will omit the api field and contain just source and sink , a module that only supports reading data assets will omit the sink field and only contain api and source capabilites.api describes the api exposed by the module to the user's workload for the particular capability. protocol field can take a value such as kafka , s3 , db2 , fybrik-arrow-flight , etc dataformat field can take a value such as parquet , csv , avro , etc endpoint field describes the endpoint exposed the module capabilites.api.endpoint describes the endpoint from a networking perspective: hostname field is the hostname to be used when accessing the module. Equals the release name. Can be omitted. port field is the port of the service exposed by the module. scheme field can take a value such as http , https , grpc , grpc+tls , jdbc:oracle:thin:@ , etc An example for a module that copies data from a db2 database table to an s3 bucket in parquet format. capabilities : - capability : copy supportedInterfaces : - source : protocol : db2 sink : protocol : s3 dataformat : parquet An example for a module that has an API for reading data, and supports reading both parquet and csv formats from s3. capabilities : - capability : read api : protocol : fybrik-arrow-flight endpoint : port : 80 scheme : grpc supportedInterfaces : - source : protocol : s3 dataformat : parquet - flow : read source : protocol : s3 dataformat : csv capabilites.actions are taken from a defined Enforcement Actions Taxonomy a module that does not perform any transformation on the data may omit the capabilities.actions field. The following is an example of how a module would declare that it knows how to redact, remove or encrypt data. Additional properties may be associated with each action. capabilities : - read : actions : - name : \"RedactAction\" - name : \"RemoveAction\" - name : \"EncryptAction\"","title":"spec.capabilities"},{"location":"contribute/modules/#full-examples","text":"The following are examples of YAMLs from fully implemented modules: An example YAML for a module that copies from db2 to s3 and includes transformation actions And an example arrow flight read module YAML, also with transformation support","title":"Full Examples"},{"location":"contribute/modules/#getting-started","text":"In order to help module developers get started there are two example \"hello world\" modules: * Hello world module * Hellow world read module An example of a fully functional module is the [arrow flight module][https://github.com/fybrik/arrow-flight-module]","title":"Getting Started"},{"location":"contribute/modules/#test","text":"Register the module to make the control plane aware of it. Create an FybrikApplication YAML for a user workload, ensuring that the data set and other parameters included in it, together with the governance policies defined in the policy manager, will result in your module being chosen based on the control plane logic . Apply the FybrikApplication YAML. View the FybrikApplication status . Run the user workload and review the results to check if they are what is expected.","title":"Test"},{"location":"contribute/documentation/","text":"Contribute Documentation The content of this website is the documentation of the project. The documentation is managed in /site/docs as markdown files. MkDocs and the Material theme are used to generate the website from these markdown files. Reference pages are auto generated from the source code. Therefore, if you change Kubernetes Custom Resource Definitions or the connectors API then you must add reasonable documentation comments. The rest of the documentation pages are written manually. Contributing to the documentation is therefore similar to code contribution and follows the same process of using pull requests. However, when writing documentation you must also follow the formatting and style guidelines.","title":"Contribute Documentation"},{"location":"contribute/documentation/#contribute-documentation","text":"The content of this website is the documentation of the project. The documentation is managed in /site/docs as markdown files. MkDocs and the Material theme are used to generate the website from these markdown files. Reference pages are auto generated from the source code. Therefore, if you change Kubernetes Custom Resource Definitions or the connectors API then you must add reasonable documentation comments. The rest of the documentation pages are written manually. Contributing to the documentation is therefore similar to code contribution and follows the same process of using pull requests. However, when writing documentation you must also follow the formatting and style guidelines.","title":"Contribute Documentation"},{"location":"contribute/documentation/formatting/","text":"Formatting Standards This page shows the formatting standards for the Fybrik documentation. Link to other pages using relative links When linking between pages in the documentation you can simply use the regular Markdown linking syntax, including the relative path to the Markdown document you wish to link to. For example: Please see the [ project license ]( license.md ) for further details. If the target documentation file is in another directory you'll need to make sure to include any relative directory path in the link: Please see the [ project license ]( ../about/license.md ) for further details. Prefer SVG format for diagrams Place image files in the docs/static directory. Use regular Markdown syntax for images. For example: ![](../static/myimage.svg) To make localization easier and enhance accessibility, the preferred image format is SVG. We recommend to use draw.io for creating images and diagrams. Use Export as to save your image in SVG format. Keep the Include a copy of my diagram option checked to allow later loading the SVG in draw.io and be sure to check Embed images if you diagram includes any. If your diagram depicts a process, try to avoid adding the descriptions of the steps to the diagram. Instead, only add the numbers of the steps to the diagram and add the descriptions of the steps as a numbered list in the document. Ensure that the numbers on the list match the numbers on your diagram. This approach helps make diagrams easier to understand and the content more accessible. Do not wrap lines Never wrap lines after a fixed number of characters or in a middle of a senstence. Instead, configure your editor to soft-wrap when editing documentation. Do Don't This is a long line. This is a long line. Use angle brackets for placeholders Use angle brackets for placeholders in commands or code samples. Tell the reader what the placeholder represents. For example: Display information about a pod: $ kubectl describe pod <pod-name> Where <pod-name> is the name of one of your pods. Use bold to emphasize user interface elements Do Don't Click Fork . Click \"Fork\". Select Other . Select 'Other'. Use bold to emphasize important text Use bold to emphasize text that is particularly important. Avoid overusing bold as it reduces its impact and readability. Do Don't Examples of bad configurations: Examples of bad configurations : The maximum length of the name field is 256 characters . The maximum length of the name field is 256 characters . Don't use capitalization for emphasis Only use the original capitalization found in the code or configuration files when referencing those values directly. Use back-ticks `` around the referenced value to make the connection explicit. For example, use IsolationPolicy , not Isolation Policy or isolation policy . If you are not referencing values or code directly, use normal sentence capitalization, for example, \"The isolation policy configuration takes place in a YAML file.\" Use italics to emphasize new terms Do Don't A cluster is a set of nodes ... A \"cluster\" is a set of nodes ... These components form the control plane . These components form the control plane . Use back-ticks around file names, directories, and paths Do Don't Open the foo.yaml file. Open the foo.yaml file. Go to the /content/docs/architecture directory. Go to the /content/docs/architecture directory. Open the /data/args.yaml file. Open the /data/args.yaml file. Use back-ticks around inline code and commands Do Don't The foo run command creates a Deployment . The \"foo run\" command creates a Deployment . For declarative management, use foo apply . For declarative management, use \"foo apply\". Use code-blocks for commands you intend readers to execute. Only use inline code and commands to mention specific labels, flags, values, functions, objects, variables, modules, or commands. Use back-ticks around object field names Do Don't Set the value of the ports field in the configuration file. Set the value of the \"ports\" field in the configuration file. The value of the rule field is a Rule object. The value of the \"rule\" field is a Rule object.","title":"Formatting Standards"},{"location":"contribute/documentation/formatting/#formatting-standards","text":"This page shows the formatting standards for the Fybrik documentation.","title":"Formatting Standards"},{"location":"contribute/documentation/formatting/#link-to-other-pages-using-relative-links","text":"When linking between pages in the documentation you can simply use the regular Markdown linking syntax, including the relative path to the Markdown document you wish to link to. For example: Please see the [ project license ]( license.md ) for further details. If the target documentation file is in another directory you'll need to make sure to include any relative directory path in the link: Please see the [ project license ]( ../about/license.md ) for further details.","title":"Link to other pages using relative links"},{"location":"contribute/documentation/formatting/#prefer-svg-format-for-diagrams","text":"Place image files in the docs/static directory. Use regular Markdown syntax for images. For example: ![](../static/myimage.svg) To make localization easier and enhance accessibility, the preferred image format is SVG. We recommend to use draw.io for creating images and diagrams. Use Export as to save your image in SVG format. Keep the Include a copy of my diagram option checked to allow later loading the SVG in draw.io and be sure to check Embed images if you diagram includes any. If your diagram depicts a process, try to avoid adding the descriptions of the steps to the diagram. Instead, only add the numbers of the steps to the diagram and add the descriptions of the steps as a numbered list in the document. Ensure that the numbers on the list match the numbers on your diagram. This approach helps make diagrams easier to understand and the content more accessible.","title":"Prefer SVG format for diagrams"},{"location":"contribute/documentation/formatting/#do-not-wrap-lines","text":"Never wrap lines after a fixed number of characters or in a middle of a senstence. Instead, configure your editor to soft-wrap when editing documentation. Do Don't This is a long line. This is a long line.","title":"Do not wrap lines"},{"location":"contribute/documentation/formatting/#use-angle-brackets-for-placeholders","text":"Use angle brackets for placeholders in commands or code samples. Tell the reader what the placeholder represents. For example: Display information about a pod: $ kubectl describe pod <pod-name> Where <pod-name> is the name of one of your pods.","title":"Use angle brackets for placeholders"},{"location":"contribute/documentation/formatting/#use-bold-to-emphasize-user-interface-elements","text":"Do Don't Click Fork . Click \"Fork\". Select Other . Select 'Other'.","title":"Use bold to emphasize user interface elements"},{"location":"contribute/documentation/formatting/#use-bold-to-emphasize-important-text","text":"Use bold to emphasize text that is particularly important. Avoid overusing bold as it reduces its impact and readability. Do Don't Examples of bad configurations: Examples of bad configurations : The maximum length of the name field is 256 characters . The maximum length of the name field is 256 characters .","title":"Use bold to emphasize important text"},{"location":"contribute/documentation/formatting/#dont-use-capitalization-for-emphasis","text":"Only use the original capitalization found in the code or configuration files when referencing those values directly. Use back-ticks `` around the referenced value to make the connection explicit. For example, use IsolationPolicy , not Isolation Policy or isolation policy . If you are not referencing values or code directly, use normal sentence capitalization, for example, \"The isolation policy configuration takes place in a YAML file.\"","title":"Don't use capitalization for emphasis"},{"location":"contribute/documentation/formatting/#use-italics-to-emphasize-new-terms","text":"Do Don't A cluster is a set of nodes ... A \"cluster\" is a set of nodes ... These components form the control plane . These components form the control plane .","title":"Use italics to emphasize new terms"},{"location":"contribute/documentation/formatting/#use-back-ticks-around-file-names-directories-and-paths","text":"Do Don't Open the foo.yaml file. Open the foo.yaml file. Go to the /content/docs/architecture directory. Go to the /content/docs/architecture directory. Open the /data/args.yaml file. Open the /data/args.yaml file.","title":"Use back-ticks around file names, directories, and paths"},{"location":"contribute/documentation/formatting/#use-back-ticks-around-inline-code-and-commands","text":"Do Don't The foo run command creates a Deployment . The \"foo run\" command creates a Deployment . For declarative management, use foo apply . For declarative management, use \"foo apply\". Use code-blocks for commands you intend readers to execute. Only use inline code and commands to mention specific labels, flags, values, functions, objects, variables, modules, or commands.","title":"Use back-ticks around inline code and commands"},{"location":"contribute/documentation/formatting/#use-back-ticks-around-object-field-names","text":"Do Don't Set the value of the ports field in the configuration file. Set the value of the \"ports\" field in the configuration file. The value of the rule field is a Rule object. The value of the \"rule\" field is a Rule object.","title":"Use back-ticks around object field names"},{"location":"contribute/documentation/style/","text":"Style Guide This page provides basic style guidance for keeping the documentation of Fybrik clear and understandable . Choose the right title Use a short, keyword-rich title that captures the intent of the document and draws the reader in. Ensure that the title clearly and concisely conveys the content or subject matter and is meaningful to a global audience. The text for the title of the document must use title case. Capitalize the first letter of every word except conjunctions and prepositions. Do Don't # Security Architecture # Security architecture # Code of Conduct # Code Of Conduct Use sentence case for headings Use sentence case for the headings in your document. Only capitalize the first word of the heading, except for proper nouns or acronyms. Do Don't Configuring rate limits Configuring Rate Limits Using Envoy for ingress Using envoy for ingress Using HTTPS Using https Use present tense Do Don't This command starts a proxy. This command will start a proxy. Exception: Use future or past tense if it is required to convey the correct meaning. This exception is extremely rare and should be avoided. Use active voice Do Don't You can explore the API using a browser. The API can be explored using a browser. The YAML file specifies the replica count. The replica count is specified in the YAML file. Use simple and direct language Use simple and direct language. Avoid using unnecessary phrases, such as saying \"please.\" Do Don't To create a ReplicaSet , ... In order to create a ReplicaSet , ... See the configuration file. Please see the configuration file. View the Pods. With this next command, we'll view the Pods. Prefer shorter words over longer alternatives Do Don't This tool helps scaling up pods. This tool facilitates scaling up pods. Pilot uses the purpose field to ... Pilot utilizes the purpose field to ... Address the reader as \"you\" Do Don't You can create a Deployment by ... We'll create a Deployment by ... In the preceding output, you can see... In the preceding output, we can see ... Avoid using \"we\" Using \"we\" in a sentence can be confusing, because the reader might not know whether they're part of the \"we\" you're describing. Do Don't Version 1.4 includes ... In version 1.4, we have added ... Fybrik provides a new feature for ... We provide a new feature ... This page teaches you how to use pods. In this page, we are going to learn about pods. Avoid jargon and idioms Some readers speak English as a second language. Avoid jargon and idioms to help make their understanding easier. Do Don't Internally, ... Under the hood, ... Create a new cluster. Turn up a new cluster. Initially, ... Out of the box, ... Avoid statements that will soon be out of date Avoid using wording that becomes outdated quickly like \"currently\" and \"new\". A feature that is new today is not new for long. Do Don't In version 1.4, ... In the current version, ... The Federation feature provides ... The new Federation feature provides ... Avoid statements about the future Avoid making promises or giving hints about the future. If you need to talk about a feature in development, add a clear indication under the front matter that identifies the information accordingly: Warning This page describes a feature that is not yet released The only exceptions to this rule are design or architecture documents that can describe a vision. However, you must clearly distiquish between implemented features and a vision. Create useful links There are good hyperlinks, and bad hyperlinks. The common practice of calling links here or click here are examples of bad hyperlinks. Check out this excellent article explaining what makes a good hyperlink and try to keep these guidelines in mind when creating or reviewing site content.","title":"Style Guide"},{"location":"contribute/documentation/style/#style-guide","text":"This page provides basic style guidance for keeping the documentation of Fybrik clear and understandable .","title":"Style Guide"},{"location":"contribute/documentation/style/#choose-the-right-title","text":"Use a short, keyword-rich title that captures the intent of the document and draws the reader in. Ensure that the title clearly and concisely conveys the content or subject matter and is meaningful to a global audience. The text for the title of the document must use title case. Capitalize the first letter of every word except conjunctions and prepositions. Do Don't # Security Architecture # Security architecture # Code of Conduct # Code Of Conduct","title":"Choose the right title"},{"location":"contribute/documentation/style/#use-sentence-case-for-headings","text":"Use sentence case for the headings in your document. Only capitalize the first word of the heading, except for proper nouns or acronyms. Do Don't Configuring rate limits Configuring Rate Limits Using Envoy for ingress Using envoy for ingress Using HTTPS Using https","title":"Use sentence case for headings"},{"location":"contribute/documentation/style/#use-present-tense","text":"Do Don't This command starts a proxy. This command will start a proxy. Exception: Use future or past tense if it is required to convey the correct meaning. This exception is extremely rare and should be avoided.","title":"Use present tense"},{"location":"contribute/documentation/style/#use-active-voice","text":"Do Don't You can explore the API using a browser. The API can be explored using a browser. The YAML file specifies the replica count. The replica count is specified in the YAML file.","title":"Use active voice"},{"location":"contribute/documentation/style/#use-simple-and-direct-language","text":"Use simple and direct language. Avoid using unnecessary phrases, such as saying \"please.\" Do Don't To create a ReplicaSet , ... In order to create a ReplicaSet , ... See the configuration file. Please see the configuration file. View the Pods. With this next command, we'll view the Pods.","title":"Use simple and direct language"},{"location":"contribute/documentation/style/#prefer-shorter-words-over-longer-alternatives","text":"Do Don't This tool helps scaling up pods. This tool facilitates scaling up pods. Pilot uses the purpose field to ... Pilot utilizes the purpose field to ...","title":"Prefer shorter words over longer alternatives"},{"location":"contribute/documentation/style/#address-the-reader-as-you","text":"Do Don't You can create a Deployment by ... We'll create a Deployment by ... In the preceding output, you can see... In the preceding output, we can see ...","title":"Address the reader as \"you\""},{"location":"contribute/documentation/style/#avoid-using-we","text":"Using \"we\" in a sentence can be confusing, because the reader might not know whether they're part of the \"we\" you're describing. Do Don't Version 1.4 includes ... In version 1.4, we have added ... Fybrik provides a new feature for ... We provide a new feature ... This page teaches you how to use pods. In this page, we are going to learn about pods.","title":"Avoid using \"we\""},{"location":"contribute/documentation/style/#avoid-jargon-and-idioms","text":"Some readers speak English as a second language. Avoid jargon and idioms to help make their understanding easier. Do Don't Internally, ... Under the hood, ... Create a new cluster. Turn up a new cluster. Initially, ... Out of the box, ...","title":"Avoid jargon and idioms"},{"location":"contribute/documentation/style/#avoid-statements-that-will-soon-be-out-of-date","text":"Avoid using wording that becomes outdated quickly like \"currently\" and \"new\". A feature that is new today is not new for long. Do Don't In version 1.4, ... In the current version, ... The Federation feature provides ... The new Federation feature provides ...","title":"Avoid statements that will soon be out of date"},{"location":"contribute/documentation/style/#avoid-statements-about-the-future","text":"Avoid making promises or giving hints about the future. If you need to talk about a feature in development, add a clear indication under the front matter that identifies the information accordingly: Warning This page describes a feature that is not yet released The only exceptions to this rule are design or architecture documents that can describe a vision. However, you must clearly distiquish between implemented features and a vision.","title":"Avoid statements about the future"},{"location":"contribute/documentation/style/#create-useful-links","text":"There are good hyperlinks, and bad hyperlinks. The common practice of calling links here or click here are examples of bad hyperlinks. Check out this excellent article explaining what makes a good hyperlink and try to keep these guidelines in mind when creating or reviewing site content.","title":"Create useful links"},{"location":"get-started/quickstart/","text":"Quick Start Guide Follow this guide to install Fybrik using default parameters that are suitable for experimentation on a single cluster. Before you begin Ensure that you have the following: Helm 3.3 or greater must be installed and configured on your machine. Kubectl 1.18 or newer must be installed on your machine. Access to a Kubernetes cluster such as Kind as a cluster administrator. Add required Helm repositories helm repo add jetstack https://charts.jetstack.io helm repo add hashicorp https://helm.releases.hashicorp.com helm repo add fybrik-charts https://fybrik.github.io/charts helm repo update Install cert-manager Fybrik requires cert-manager to be installed to your cluster. Many clusters already include cert-manager. Check if cert-manager namespace exists in your cluster and only run the following if it doesn't exist: helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --version v1.2.0 \\ --create-namespace \\ --set installCRDs = true \\ --wait --timeout 120s Install Hashicorp Vault and plugins Hashicorp Vault and a secrets-kubernetes-reader plugin are used by Fybrik for credential management. Install latest development version from GitHub The published Helm charts are only available for released versions. To install the dev version install the charts from the source code. For example: Kubernetes OpenShift git clone https://github.com/fybrik/fybrik.git cd fybrik helm dependency update charts/vault helm install vault charts/vault --create-namespace -n fybrik-system \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s git clone https://github.com/fybrik/fybrik.git cd fybrik helm dependency update charts/vault helm install vault charts/vault --create-namespace -n fybrik-system \\ --set \"vault.global.openshift=true\" \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s Run the following to install vault and the plugin in development mode: Kubernetes OpenShift helm install vault fybrik-charts/vault --create-namespace -n fybrik-system \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values https://raw.githubusercontent.com/fybrik/fybrik/v0.4.0/charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s helm install vault fybrik-charts/vault --create-namespace -n fybrik-system \\ --set \"vault.global.openshift=true\" \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values https://raw.githubusercontent.com/fybrik/fybrik/v0.4.0/charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s Install control plane Install latest development version from GitHub The published Helm charts are only available for released versions. To install the dev version install the charts from the source code. For example: git clone https://github.com/fybrik/fybrik.git cd fybrik helm install fybrik-crd charts/fybrik-crd -n fybrik-system --wait helm install fybrik charts/fybrik --set global.tag = master --set global.imagePullPolicy = Always -n fybrik-system --wait The control plane includes a manager service that connects to a data catalog and to a policy manager. Install the latest release of Fybrik with a built-in data catalog and with Open Policy Agent as the policy manager: helm install fybrik-crd fybrik-charts/fybrik-crd -n fybrik-system --wait helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait Install modules Install latest development version from GitHub To apply the latest development version of arrow-flight-module: kubectl apply -f https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml -n fybrik-system Modules are plugins that the control plane deploys whenever required. The arrow flight module enables reading data through Apache Arrow Flight API. Install the latest 1 release of arrow-flight-module: kubectl apply -f https://github.com/fybrik/arrow-flight-module/releases/latest/download/module.yaml -n fybrik-system Refer to the documentation of arrow-flight-module for other versions \u21a9","title":"Quick Start Guide"},{"location":"get-started/quickstart/#quick-start-guide","text":"Follow this guide to install Fybrik using default parameters that are suitable for experimentation on a single cluster.","title":"Quick Start Guide"},{"location":"get-started/quickstart/#before-you-begin","text":"Ensure that you have the following: Helm 3.3 or greater must be installed and configured on your machine. Kubectl 1.18 or newer must be installed on your machine. Access to a Kubernetes cluster such as Kind as a cluster administrator.","title":"Before you begin"},{"location":"get-started/quickstart/#add-required-helm-repositories","text":"helm repo add jetstack https://charts.jetstack.io helm repo add hashicorp https://helm.releases.hashicorp.com helm repo add fybrik-charts https://fybrik.github.io/charts helm repo update","title":"Add required Helm repositories"},{"location":"get-started/quickstart/#install-cert-manager","text":"Fybrik requires cert-manager to be installed to your cluster. Many clusters already include cert-manager. Check if cert-manager namespace exists in your cluster and only run the following if it doesn't exist: helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --version v1.2.0 \\ --create-namespace \\ --set installCRDs = true \\ --wait --timeout 120s","title":"Install cert-manager"},{"location":"get-started/quickstart/#install-hashicorp-vault-and-plugins","text":"Hashicorp Vault and a secrets-kubernetes-reader plugin are used by Fybrik for credential management. Install latest development version from GitHub The published Helm charts are only available for released versions. To install the dev version install the charts from the source code. For example: Kubernetes OpenShift git clone https://github.com/fybrik/fybrik.git cd fybrik helm dependency update charts/vault helm install vault charts/vault --create-namespace -n fybrik-system \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s git clone https://github.com/fybrik/fybrik.git cd fybrik helm dependency update charts/vault helm install vault charts/vault --create-namespace -n fybrik-system \\ --set \"vault.global.openshift=true\" \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s Run the following to install vault and the plugin in development mode: Kubernetes OpenShift helm install vault fybrik-charts/vault --create-namespace -n fybrik-system \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values https://raw.githubusercontent.com/fybrik/fybrik/v0.4.0/charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s helm install vault fybrik-charts/vault --create-namespace -n fybrik-system \\ --set \"vault.global.openshift=true\" \\ --set \"vault.injector.enabled=false\" \\ --set \"vault.server.dev.enabled=true\" \\ --values https://raw.githubusercontent.com/fybrik/fybrik/v0.4.0/charts/vault/env/dev/vault-single-cluster-values.yaml kubectl wait --for = condition = ready --all pod -n fybrik-system --timeout = 120s","title":"Install Hashicorp Vault and plugins"},{"location":"get-started/quickstart/#install-control-plane","text":"Install latest development version from GitHub The published Helm charts are only available for released versions. To install the dev version install the charts from the source code. For example: git clone https://github.com/fybrik/fybrik.git cd fybrik helm install fybrik-crd charts/fybrik-crd -n fybrik-system --wait helm install fybrik charts/fybrik --set global.tag = master --set global.imagePullPolicy = Always -n fybrik-system --wait The control plane includes a manager service that connects to a data catalog and to a policy manager. Install the latest release of Fybrik with a built-in data catalog and with Open Policy Agent as the policy manager: helm install fybrik-crd fybrik-charts/fybrik-crd -n fybrik-system --wait helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait","title":"Install control plane"},{"location":"get-started/quickstart/#install-modules","text":"Install latest development version from GitHub To apply the latest development version of arrow-flight-module: kubectl apply -f https://raw.githubusercontent.com/fybrik/arrow-flight-module/master/module.yaml -n fybrik-system Modules are plugins that the control plane deploys whenever required. The arrow flight module enables reading data through Apache Arrow Flight API. Install the latest 1 release of arrow-flight-module: kubectl apply -f https://github.com/fybrik/arrow-flight-module/releases/latest/download/module.yaml -n fybrik-system Refer to the documentation of arrow-flight-module for other versions \u21a9","title":"Install modules"},{"location":"reference/connectors/","text":"Protocol Documentation Top credentials.proto Credentials Field Type Label Description access_key string access credential for the bucket where the asset is stored secret_key string username string password string api_key string api key assigned to the bucket in which the asset is stored resource_instance_id string resource instance id for the bucket Top data_catalog_request.proto CatalogDatasetRequest Field Type Label Description credential_path string link to vault plugin for reading k8s secret with user credentials dataset_id string identifier of asset - always needed. JSON expected. Interpreted by the Connector, can contain any additional information as part of JSON Top data_catalog_response.proto CatalogDatasetInfo Field Type Label Description dataset_id string details DatasetDetails Top data_catalog_service.proto DataCatalogService Method Name Request Type Response Type Description GetDatasetInfo CatalogDatasetRequest CatalogDatasetInfo RegisterDatasetInfo RegisterAssetRequest RegisterAssetResponse Top dataset_details.proto CredentialsInfo Field Type Label Description vault_secret_path string the path to Vault secret which is used to retrive the dataset credentials from the catalog. DataComponentMetadata Field Type Label Description component_type string e.g., column named_metadata DataComponentMetadata.NamedMetadataEntry repeated Named terms, that exist in Catalog toxonomy and the values for these terms for columns we will have \"SchemaDetails\" key, that will include technical schema details for this column TODO: Consider create special field for schema outside of metadata tags string repeated Tags - can be any free text added to a component (no taxonomy) DataComponentMetadata.NamedMetadataEntry Field Type Label Description key string value string DataStore Field Type Label Description type DataStore.DataStoreType name string for auditing and readability. Can be same as location type or can have more info if availble from catalog db2 Db2DataStore oneof location { // should have been oneof but for technical rasons, a problem to translate it to JSON, we remove the oneof for now should have been local, db2, s3 without \"location\" but had a problem to compile it in proto - collision with proto name DataLocationDb2 s3 S3DataStore kafka KafkaDataStore DatasetDetails Field Type Label Description name string name in Catalog data_owner string information on the owner of data asset - can have different formats for different catalogs data_store DataStore All info about the data store data_format string geo string geography location where data resides (if this information available) metadata DatasetMetadata LocationType locationType = 10; //publicCloud/privateCloud etc. Should be filled later when we understand better if we have a closed set of values and how they are used. credentials_info CredentialsInfo information about how to retrive dataset credentials from the catalog. DatasetMetadata Field Type Label Description dataset_named_metadata DatasetMetadata.DatasetNamedMetadataEntry repeated dataset_tags string repeated Tags - can be any free text added to a component (no taxonomy) components_metadata DatasetMetadata.ComponentsMetadataEntry repeated metadata for each component in asset. In tabular data each column is a component, then we will have: column name -> column metadata DatasetMetadata.ComponentsMetadataEntry Field Type Label Description key string value DataComponentMetadata DatasetMetadata.DatasetNamedMetadataEntry Field Type Label Description key string value string Db2DataStore Field Type Label Description url string database string table string reformat to SCHEMA.TABLE struct port string ssl string Note that bool value if set to \"false\" does not appear in the struct at all KafkaDataStore Field Type Label Description topic_name string bootstrap_servers string schema_registry string key_deserializer string value_deserializer string security_protocol string sasl_mechanism string ssl_truststore string ssl_truststore_password string S3DataStore Field Type Label Description endpoint string endpoint should contain only the host name without the scheme i.e., \"s3.eu-gb.cloud-object-storage.appdomain.cloud\" bucket string object_key string can be object name or the prefix for dataset region string WKC does not return it, it will stay empty in our case!!! DataStore.DataStoreType Name Number Description UNKNOWN 0 LOCAL 1 S3 2 DB2 3 KAFKA 4 Top policy_manager_request.proto AccessOperation Field Type Label Description type AccessOperation.AccessType destination string Destination for transfer or write. ApplicationContext Field Type Label Description credential_path string link to vault plugin for reading k8s secret with user credentials app_info ApplicationDetails datasets DatasetContext repeated general_operations AccessOperation repeated ApplicationDetails Field Type Label Description processing_geography string properties ApplicationDetails.PropertiesEntry repeated ApplicationDetails.PropertiesEntry Field Type Label Description key string value string DatasetContext Field Type Label Description dataset DatasetIdentifier operation AccessOperation DatasetIdentifier Field Type Label Description dataset_id string identifier of asset - always needed. JSON expected. Interpreted by the Connector, can contain any additional information as part of JSON AccessOperation.AccessType Name Number Description UNKNOWN 0 READ 1 COPY 2 WRITE 3 Top policy_manager_response.proto ComponentVersion Field Type Label Description name string id string version string DatasetDecision Field Type Label Description dataset DatasetIdentifier decisions OperationDecision repeated EnforcementAction Field Type Label Description name string id string level EnforcementAction.EnforcementActionLevel args EnforcementAction.ArgsEntry repeated EnforcementAction.ArgsEntry Field Type Label Description key string value string OperationDecision Field Type Label Description operation AccessOperation enforcement_actions EnforcementAction repeated used_policies Policy repeated PoliciesDecisions Field Type Label Description component_versions ComponentVersion repeated dataset_decisions DatasetDecision repeated one per dataset general_decisions OperationDecision repeated Policy Field Type Label Description id string name string description string type string hierarchy string repeated EnforcementAction.EnforcementActionLevel Name Number Description UNKNOWN 0 DATASET 1 COLUMN 2 ROW 3 CELL 4 Top policy_manager_service.proto PolicyManagerService Method Name Request Type Response Type Description GetPoliciesDecisions ApplicationContext PoliciesDecisions Top register_asset_request.proto RegisterAssetRequest Field Type Label Description creds Credentials dataset_details DatasetDetails destination_catalog_id string credential_path string link to vault plugin for reading k8s secret with user credentials Top register_asset_response.proto RegisterAssetResponse Field Type Label Description asset_id string Returns the id of the new asset registered in a catalog Scalar Value Types .proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Connectors API"},{"location":"reference/connectors/#protocol-documentation","text":"Top","title":"Protocol Documentation"},{"location":"reference/connectors/#credentialsproto","text":"","title":"credentials.proto"},{"location":"reference/connectors/#credentials","text":"Field Type Label Description access_key string access credential for the bucket where the asset is stored secret_key string username string password string api_key string api key assigned to the bucket in which the asset is stored resource_instance_id string resource instance id for the bucket Top","title":"Credentials"},{"location":"reference/connectors/#data_catalog_requestproto","text":"","title":"data_catalog_request.proto"},{"location":"reference/connectors/#catalogdatasetrequest","text":"Field Type Label Description credential_path string link to vault plugin for reading k8s secret with user credentials dataset_id string identifier of asset - always needed. JSON expected. Interpreted by the Connector, can contain any additional information as part of JSON Top","title":"CatalogDatasetRequest"},{"location":"reference/connectors/#data_catalog_responseproto","text":"","title":"data_catalog_response.proto"},{"location":"reference/connectors/#catalogdatasetinfo","text":"Field Type Label Description dataset_id string details DatasetDetails Top","title":"CatalogDatasetInfo"},{"location":"reference/connectors/#data_catalog_serviceproto","text":"","title":"data_catalog_service.proto"},{"location":"reference/connectors/#datacatalogservice","text":"Method Name Request Type Response Type Description GetDatasetInfo CatalogDatasetRequest CatalogDatasetInfo RegisterDatasetInfo RegisterAssetRequest RegisterAssetResponse Top","title":"DataCatalogService"},{"location":"reference/connectors/#dataset_detailsproto","text":"","title":"dataset_details.proto"},{"location":"reference/connectors/#credentialsinfo","text":"Field Type Label Description vault_secret_path string the path to Vault secret which is used to retrive the dataset credentials from the catalog.","title":"CredentialsInfo"},{"location":"reference/connectors/#datacomponentmetadata","text":"Field Type Label Description component_type string e.g., column named_metadata DataComponentMetadata.NamedMetadataEntry repeated Named terms, that exist in Catalog toxonomy and the values for these terms for columns we will have \"SchemaDetails\" key, that will include technical schema details for this column TODO: Consider create special field for schema outside of metadata tags string repeated Tags - can be any free text added to a component (no taxonomy)","title":"DataComponentMetadata"},{"location":"reference/connectors/#datacomponentmetadatanamedmetadataentry","text":"Field Type Label Description key string value string","title":"DataComponentMetadata.NamedMetadataEntry"},{"location":"reference/connectors/#datastore","text":"Field Type Label Description type DataStore.DataStoreType name string for auditing and readability. Can be same as location type or can have more info if availble from catalog db2 Db2DataStore oneof location { // should have been oneof but for technical rasons, a problem to translate it to JSON, we remove the oneof for now should have been local, db2, s3 without \"location\" but had a problem to compile it in proto - collision with proto name DataLocationDb2 s3 S3DataStore kafka KafkaDataStore","title":"DataStore"},{"location":"reference/connectors/#datasetdetails","text":"Field Type Label Description name string name in Catalog data_owner string information on the owner of data asset - can have different formats for different catalogs data_store DataStore All info about the data store data_format string geo string geography location where data resides (if this information available) metadata DatasetMetadata LocationType locationType = 10; //publicCloud/privateCloud etc. Should be filled later when we understand better if we have a closed set of values and how they are used. credentials_info CredentialsInfo information about how to retrive dataset credentials from the catalog.","title":"DatasetDetails"},{"location":"reference/connectors/#datasetmetadata","text":"Field Type Label Description dataset_named_metadata DatasetMetadata.DatasetNamedMetadataEntry repeated dataset_tags string repeated Tags - can be any free text added to a component (no taxonomy) components_metadata DatasetMetadata.ComponentsMetadataEntry repeated metadata for each component in asset. In tabular data each column is a component, then we will have: column name -> column metadata","title":"DatasetMetadata"},{"location":"reference/connectors/#datasetmetadatacomponentsmetadataentry","text":"Field Type Label Description key string value DataComponentMetadata","title":"DatasetMetadata.ComponentsMetadataEntry"},{"location":"reference/connectors/#datasetmetadatadatasetnamedmetadataentry","text":"Field Type Label Description key string value string","title":"DatasetMetadata.DatasetNamedMetadataEntry"},{"location":"reference/connectors/#db2datastore","text":"Field Type Label Description url string database string table string reformat to SCHEMA.TABLE struct port string ssl string Note that bool value if set to \"false\" does not appear in the struct at all","title":"Db2DataStore"},{"location":"reference/connectors/#kafkadatastore","text":"Field Type Label Description topic_name string bootstrap_servers string schema_registry string key_deserializer string value_deserializer string security_protocol string sasl_mechanism string ssl_truststore string ssl_truststore_password string","title":"KafkaDataStore"},{"location":"reference/connectors/#s3datastore","text":"Field Type Label Description endpoint string endpoint should contain only the host name without the scheme i.e., \"s3.eu-gb.cloud-object-storage.appdomain.cloud\" bucket string object_key string can be object name or the prefix for dataset region string WKC does not return it, it will stay empty in our case!!!","title":"S3DataStore"},{"location":"reference/connectors/#datastoredatastoretype","text":"Name Number Description UNKNOWN 0 LOCAL 1 S3 2 DB2 3 KAFKA 4 Top","title":"DataStore.DataStoreType"},{"location":"reference/connectors/#policy_manager_requestproto","text":"","title":"policy_manager_request.proto"},{"location":"reference/connectors/#accessoperation","text":"Field Type Label Description type AccessOperation.AccessType destination string Destination for transfer or write.","title":"AccessOperation"},{"location":"reference/connectors/#applicationcontext","text":"Field Type Label Description credential_path string link to vault plugin for reading k8s secret with user credentials app_info ApplicationDetails datasets DatasetContext repeated general_operations AccessOperation repeated","title":"ApplicationContext"},{"location":"reference/connectors/#applicationdetails","text":"Field Type Label Description processing_geography string properties ApplicationDetails.PropertiesEntry repeated","title":"ApplicationDetails"},{"location":"reference/connectors/#applicationdetailspropertiesentry","text":"Field Type Label Description key string value string","title":"ApplicationDetails.PropertiesEntry"},{"location":"reference/connectors/#datasetcontext","text":"Field Type Label Description dataset DatasetIdentifier operation AccessOperation","title":"DatasetContext"},{"location":"reference/connectors/#datasetidentifier","text":"Field Type Label Description dataset_id string identifier of asset - always needed. JSON expected. Interpreted by the Connector, can contain any additional information as part of JSON","title":"DatasetIdentifier"},{"location":"reference/connectors/#accessoperationaccesstype","text":"Name Number Description UNKNOWN 0 READ 1 COPY 2 WRITE 3 Top","title":"AccessOperation.AccessType"},{"location":"reference/connectors/#policy_manager_responseproto","text":"","title":"policy_manager_response.proto"},{"location":"reference/connectors/#componentversion","text":"Field Type Label Description name string id string version string","title":"ComponentVersion"},{"location":"reference/connectors/#datasetdecision","text":"Field Type Label Description dataset DatasetIdentifier decisions OperationDecision repeated","title":"DatasetDecision"},{"location":"reference/connectors/#enforcementaction","text":"Field Type Label Description name string id string level EnforcementAction.EnforcementActionLevel args EnforcementAction.ArgsEntry repeated","title":"EnforcementAction"},{"location":"reference/connectors/#enforcementactionargsentry","text":"Field Type Label Description key string value string","title":"EnforcementAction.ArgsEntry"},{"location":"reference/connectors/#operationdecision","text":"Field Type Label Description operation AccessOperation enforcement_actions EnforcementAction repeated used_policies Policy repeated","title":"OperationDecision"},{"location":"reference/connectors/#policiesdecisions","text":"Field Type Label Description component_versions ComponentVersion repeated dataset_decisions DatasetDecision repeated one per dataset general_decisions OperationDecision repeated","title":"PoliciesDecisions"},{"location":"reference/connectors/#policy","text":"Field Type Label Description id string name string description string type string hierarchy string repeated","title":"Policy"},{"location":"reference/connectors/#enforcementactionenforcementactionlevel","text":"Name Number Description UNKNOWN 0 DATASET 1 COLUMN 2 ROW 3 CELL 4 Top","title":"EnforcementAction.EnforcementActionLevel"},{"location":"reference/connectors/#policy_manager_serviceproto","text":"","title":"policy_manager_service.proto"},{"location":"reference/connectors/#policymanagerservice","text":"Method Name Request Type Response Type Description GetPoliciesDecisions ApplicationContext PoliciesDecisions Top","title":"PolicyManagerService"},{"location":"reference/connectors/#register_asset_requestproto","text":"","title":"register_asset_request.proto"},{"location":"reference/connectors/#registerassetrequest","text":"Field Type Label Description creds Credentials dataset_details DatasetDetails destination_catalog_id string credential_path string link to vault plugin for reading k8s secret with user credentials Top","title":"RegisterAssetRequest"},{"location":"reference/connectors/#register_asset_responseproto","text":"","title":"register_asset_response.proto"},{"location":"reference/connectors/#registerassetresponse","text":"Field Type Label Description asset_id string Returns the id of the new asset registered in a catalog","title":"RegisterAssetResponse"},{"location":"reference/connectors/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"reference/crds/","text":"API Reference Packages: app.fybrik.io/v1alpha1 katalog.fybrik.io/v1alpha1 app.fybrik.io/v1alpha1 Resource Types: Blueprint FybrikApplication FybrikModule FybrikStorageAccount Plotter Blueprint \u21a9 Parent Blueprint is the Schema for the blueprints API Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string Blueprint true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object BlueprintSpec defines the desired state of Blueprint, which defines the components of the workload's data path that run in a particular cluster. In a single cluster environment there is one blueprint per workload (FybrikApplication). In a multi-cluster environment there is one Blueprint per cluster per workload (FybrikApplication). false status object BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring false Blueprint.spec \u21a9 Parent BlueprintSpec defines the desired state of Blueprint, which defines the components of the workload's data path that run in a particular cluster. In a single cluster environment there is one blueprint per workload (FybrikApplication). In a multi-cluster environment there is one Blueprint per cluster per workload (FybrikApplication). Name Type Description Required cluster string Cluster indicates the cluster on which the Blueprint runs true modules map[string]object Modules is a map which contains modules that indicate the data path components that run in this cluster The map key is moduleInstanceName which is the unique name for the deployed instance related to this workload true modulesNamespace string ModulesNamespace is the namespace where modules should be allocated true Blueprint.spec.modules[key] \u21a9 Parent BlueprintModule is a copy of a FybrikModule Custom Resource. It contains the information necessary to instantiate a datapath component, including the parameters relevant for the particular workload. Name Type Description Required arguments object Arguments are the input parameters for a specific instance of a module. false assetIds []string assetIDs indicate the assets processed by this module. Included so we can track asset status as well as module status in the future. false chart object Chart contains the location of the helm chart with info detailing how to deploy true name string Name of the FybrikModule on which this is based true Blueprint.spec.modules[key].arguments \u21a9 Parent Arguments are the input parameters for a specific instance of a module. Name Type Description Required appSelector object Application selector is used to identify the user workload. It is obtained from FybrikApplication spec. false copy object CopyArgs are parameters specific to modules that copy data from one data store to another. false labels map[string]string Labels of FybrikApplication false read []object ReadArgs are parameters that are specific to modules that enable an application to read data false write []object WriteArgs are parameters that are specific to modules that enable an application to write data false Blueprint.spec.modules[key].arguments.appSelector \u21a9 Parent Application selector is used to identify the user workload. It is obtained from FybrikApplication spec. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false Blueprint.spec.modules[key].arguments.appSelector.matchExpressions[index] \u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true Blueprint.spec.modules[key].arguments.copy \u21a9 Parent CopyArgs are parameters specific to modules that copy data from one data store to another. Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data as it is copied. false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true destination object Destination is the data store to which the data will be copied true source object Source is the where the data currently resides true Blueprint.spec.modules[key].arguments.copy.transformations[index] \u21a9 Parent Name Type Description Required name string true Blueprint.spec.modules[key].arguments.copy.destination \u21a9 Parent Destination is the data store to which the data will be copied Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true Blueprint.spec.modules[key].arguments.copy.destination.connection \u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true Blueprint.spec.modules[key].arguments.copy.destination.vault[key] \u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true Blueprint.spec.modules[key].arguments.copy.source \u21a9 Parent Source is the where the data currently resides Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true Blueprint.spec.modules[key].arguments.copy.source.connection \u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true Blueprint.spec.modules[key].arguments.copy.source.vault[key] \u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true Blueprint.spec.modules[key].arguments.read[index] \u21a9 Parent ReadModuleArgs define the input parameters for modules that read data from location A Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true source object Source of the read path module true Blueprint.spec.modules[key].arguments.read[index].transformations[index] \u21a9 Parent Name Type Description Required name string true Blueprint.spec.modules[key].arguments.read[index].source \u21a9 Parent Source of the read path module Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true Blueprint.spec.modules[key].arguments.read[index].source.connection \u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true Blueprint.spec.modules[key].arguments.read[index].source.vault[key] \u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true Blueprint.spec.modules[key].arguments.write[index] \u21a9 Parent WriteModuleArgs define the input parameters for modules that write data to location B Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data as it is written. false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true destination object Destination is the data store to which the data will be written true Blueprint.spec.modules[key].arguments.write[index].transformations[index] \u21a9 Parent Name Type Description Required name string true Blueprint.spec.modules[key].arguments.write[index].destination \u21a9 Parent Destination is the data store to which the data will be written Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true Blueprint.spec.modules[key].arguments.write[index].destination.connection \u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true Blueprint.spec.modules[key].arguments.write[index].destination.vault[key] \u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true Blueprint.spec.modules[key].chart \u21a9 Parent Chart contains the location of the helm chart with info detailing how to deploy Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true Blueprint.status \u21a9 Parent BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring Name Type Description Required modules map[string]object ModulesState is a map which holds the status of each module its key is the moduleInstanceName which is the unique name for the deployed instance related to this workload false observedGeneration integer ObservedGeneration is taken from the Blueprint metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated resources should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false releases map[string]integer Releases map each release to the observed generation of the blueprint containing this release. At the end of reconcile, each release should be mapped to the latest blueprint version or be uninstalled. false Blueprint.status.modules[key] \u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Blueprint.status.observedState \u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false FybrikApplication \u21a9 Parent FybrikApplication provides information about the application whose data is being operated on, the nature of the processing, and the data sets chosen for processing by the application. The FybrikApplication controller obtains instructions regarding any governance related changes that must be performed on the data, identifies the modules capable of performing such changes, and finally generates the Plotter which defines the secure runtime environment and all the components in it. This runtime environment provides the application with access to the data requested in a secure manner and without having to provide any credentials for the data sets. The credentials are obtained automatically by the manager from the credential management system. Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikApplication true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object FybrikApplicationSpec defines data flows needed by the application, the purpose and other contextual information about the application. Read flow - if selector is populated, fybrik builds a data plane for reading the specified data sets Ingest flow - if no selector, and data/copy/required is true then the data specified is copied into a bucket allocated by fybrik and is cataloged in the data catalog false status object FybrikApplicationStatus defines the observed state of FybrikApplication. false FybrikApplication.spec \u21a9 Parent FybrikApplicationSpec defines data flows needed by the application, the purpose and other contextual information about the application. Read flow - if selector is populated, fybrik builds a data plane for reading the specified data sets Ingest flow - if no selector, and data/copy/required is true then the data specified is copied into a bucket allocated by fybrik and is cataloged in the data catalog Name Type Description Required secretRef string SecretRef points to the secret that holds credentials for each system the user has been authenticated with. The secret is deployed in FybrikApplication namespace. false selector object Selector enables to connect the resource to the application Application labels should match the labels in the selector. false appInfo map[string]string AppInfo contains information describing the reasons for the processing that will be done by the application. true data []object Data contains the identifiers of the data to be used by the Data Scientist's application, and the protocol used to access it and the format expected. true FybrikApplication.spec.selector \u21a9 Parent Selector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required clusterName string Cluster name false workloadSelector object WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. true FybrikApplication.spec.selector.workloadSelector \u21a9 Parent WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false FybrikApplication.spec.selector.workloadSelector.matchExpressions[index] \u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true FybrikApplication.spec.data[index] \u21a9 Parent DataContext indicates data set chosen by the Data Scientist to be used by his application, and includes information about the data format and technologies used by the application to access the data. Name Type Description Required catalogService string CatalogService represents the catalog service for accessing the requested dataset. If not specified, the enterprise catalog service will be used. false dataSetID string DataSetID is a unique identifier of the dataset chosen from the data catalog for processing by the data user application. true requirements object Requirements from the system true FybrikApplication.spec.data[index].requirements \u21a9 Parent Requirements from the system Name Type Description Required copy object CopyRequrements include the requirements for copying the data false interface object Interface indicates the protocol and format expected by the data user true FybrikApplication.spec.data[index].requirements.copy \u21a9 Parent CopyRequrements include the requirements for copying the data Name Type Description Required catalog object Catalog indicates that the data asset must be cataloged. false required boolean Required indicates that the data must be copied. false FybrikApplication.spec.data[index].requirements.copy.catalog \u21a9 Parent Catalog indicates that the data asset must be cataloged. Name Type Description Required catalogID string CatalogID specifies the catalog where the data will be cataloged. false service string CatalogService specifies the datacatalog service that will be used for catalogging the data into. false FybrikApplication.spec.data[index].requirements.interface \u21a9 Parent Interface indicates the protocol and format expected by the data user Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true FybrikApplication.status \u21a9 Parent FybrikApplicationStatus defines the observed state of FybrikApplication. Name Type Description Required assetStates map[string]object AssetStates provides a status per asset false errorMessage string ErrorMessage indicates that an error has happened during the reconcile, unrelated to a specific asset false generated object Generated resource identifier false observedGeneration integer ObservedGeneration is taken from the FybrikApplication metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether the Blueprint status changed. Format : int64 false provisionedStorage map[string]object ProvisionedStorage maps a dataset (identified by AssetID) to the new provisioned bucket. It allows FybrikApplication controller to manage buckets in case the spec has been modified, an error has occurred, or a delete event has been received. ProvisionedStorage has the information required to register the dataset once the owned plotter resource is ready false ready boolean Ready is true if all specified assets are either ready to be used or are denied access. false validApplication string ValidApplication indicates whether the FybrikApplication is valid given the defined taxonomy false validatedGeneration integer ValidatedGeneration is the version of the FyrbikApplication that has been validated with the taxonomy defined. Format : int64 false FybrikApplication.status.assetStates[key] \u21a9 Parent AssetState defines the observed state of an asset Name Type Description Required catalogedAsset string CatalogedAsset provides a new asset identifier after being registered in the enterprise catalog false conditions []object Conditions indicate the asset state (Ready, Deny, Error) false endpoint object Endpoint provides the endpoint spec from which the asset will be served to the application false FybrikApplication.status.assetStates[key].conditions[index] \u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true FybrikApplication.status.assetStates[key].endpoint \u21a9 Parent Endpoint provides the endpoint spec from which the asset will be served to the application Name Type Description Required name string true FybrikApplication.status.generated \u21a9 Parent Generated resource identifier Name Type Description Required appVersion integer Version of FybrikApplication that has generated this resource Format : int64 true kind string Kind of the resource (Blueprint, Plotter) true name string Name of the resource true namespace string Namespace of the resource true FybrikApplication.status.provisionedStorage[key] \u21a9 Parent DatasetDetails holds details of the provisioned storage Name Type Description Required datasetRef string Reference to a Dataset resource containing the request to provision storage false secretRef string Reference to a secret where the credentials are stored false FybrikModule \u21a9 Parent FybrikModule is a description of an injectable component. the parameters it requires, as well as the specification of how to instantiate such a component. It is used as metadata only. There is no status nor reconciliation. Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikModule true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true status object FybrikModuleStatus defines the observed state of FybrikModule. false spec object FybrikModuleSpec contains the info common to all modules, which are one of the components that process, load, write, audit, monitor the data used by the data scientist's application. true FybrikModule.status \u21a9 Parent FybrikModuleStatus defines the observed state of FybrikModule. Name Type Description Required conditions []object Conditions indicate the module states with respect to validation false FybrikModule.status.conditions[index] \u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true FybrikModule.spec \u21a9 Parent FybrikModuleSpec contains the info common to all modules, which are one of the components that process, load, write, audit, monitor the data used by the data scientist's application. Name Type Description Required dependencies []object Other components that must be installed in order for this module to work false description string An explanation of what this module does false pluginType string Plugin type indicates the plugin technology used to invoke the capabilities Ex: vault, fybrik-wasm... Should be provided if type is plugin false statusIndicators []object StatusIndicators allow to check status of a non-standard resource that can not be computed by helm/kstatus false capabilities []object Capabilities declares what this module knows how to do and the types of data it knows how to handle The key to the map is a CapabilityType string true chart object Reference to a Helm chart that allows deployment of the resources required for this module true type string May be one of service, config or plugin Service: Means that the control plane deploys the component that performs the capability Config: Another pre-installed service performs the capability and the module deployed configures it for the particular workload or dataset Plugin: Indicates that this module performs a capability as part of another service or module rather than as a stand-alone module true FybrikModule.spec.dependencies[index] \u21a9 Parent Dependency details another component on which this module relies - i.e. a pre-requisit Name Type Description Required name string Name is the name of the dependent component true type enum Type provides information used in determining how to instantiate the component Enum : module, connector, feature true FybrikModule.spec.statusIndicators[index] \u21a9 Parent ResourceStatusIndicator is used to determine the status of an orchestrated resource Name Type Description Required errorMessage string ErrorMessage specifies the resource field to check for an error, e.g. status.errorMsg false failureCondition string FailureCondition specifies a condition that indicates the resource failure It uses kubernetes label selection syntax (https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) false kind string Kind provides information about the resource kind true successCondition string SuccessCondition specifies a condition that indicates that the resource is ready It uses kubernetes label selection syntax (https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) true FybrikModule.spec.capabilities[index] \u21a9 Parent Capability declares what this module knows how to do and the types of data it knows how to handle Name Type Description Required actions []object Actions are the data transformations that the module supports false api object API indicates to the application how to access the capabilities provided by the module false plugins []object Plugins enable the module to add libraries to perform actions rather than implementing them by itself false scope enum Scope indicates at what level the capability is used: workload, asset, cluster If not indicated it is assumed to be asset Enum : asset, workload, cluster false supportedInterfaces []object Copy should have one or more instances in the list, and its content should have source and sink Read should have one or more instances in the list, each with source populated Write should have one or more instances in the list, each with sink populated This field may not be required if not handling data false capability string Capability declares what this module knows how to do - ex: read, write, transform... true FybrikModule.spec.capabilities[index].actions[index] \u21a9 Parent Name Type Description Required name string true FybrikModule.spec.capabilities[index].api \u21a9 Parent API indicates to the application how to access the capabilities provided by the module Name Type Description Required dataFormat string Data format false connection object Connection information true FybrikModule.spec.capabilities[index].api.connection \u21a9 Parent Connection information Name Type Description Required name string true FybrikModule.spec.capabilities[index].plugins[index] \u21a9 Parent Name Type Description Required dataFormat string DataFormat indicates the format of data the plugin knows how to process true pluginType string PluginType indicates the technology used for the module and the plugin to interact The values supported should come from the module taxonomy Examples of such mechanisms are vault plugins, wasm, etc true FybrikModule.spec.capabilities[index].supportedInterfaces[index] \u21a9 Parent ModuleInOut specifies the protocol and format of the data input and output by the module - if any Name Type Description Required sink object Sink specifies the output data protocol and format false source object Source specifies the input data protocol and format false FybrikModule.spec.capabilities[index].supportedInterfaces[index].sink \u21a9 Parent Sink specifies the output data protocol and format Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true FybrikModule.spec.capabilities[index].supportedInterfaces[index].source \u21a9 Parent Source specifies the input data protocol and format Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true FybrikModule.spec.chart \u21a9 Parent Reference to a Helm chart that allows deployment of the resources required for this module Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true FybrikStorageAccount \u21a9 Parent FybrikStorageAccount defines a storage account used for copying data. Only S3 based storage is supported. It contains endpoint, region and a reference to the credentials a Owner of the asset is responsible to store the credentials Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikStorageAccount true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object FybrikStorageAccountSpec defines the desired state of FybrikStorageAccount false status object FybrikStorageAccountStatus defines the observed state of FybrikStorageAccount false FybrikStorageAccount.spec \u21a9 Parent FybrikStorageAccountSpec defines the desired state of FybrikStorageAccount Name Type Description Required endpoints map[string]string Endpoints based on regions true id string Identification of a storage account true secretRef string A name of k8s secret deployed in the control plane. This secret includes secretKey and accessKey credentials for S3 bucket true Plotter \u21a9 Parent Plotter is the Schema for the plotters API Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string Plotter true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object PlotterSpec defines the desired state of Plotter, which is applied in a multi-clustered environment. Plotter declares what needs to be installed and where (as blueprints running on remote clusters) which provides the Data Scientist's application with secure and governed access to the data requested in the FybrikApplication. false status object PlotterStatus defines the observed state of Plotter This includes readiness, error message, and indicators received from blueprint resources owned by the Plotter for cleanup and status monitoring false Plotter.spec \u21a9 Parent PlotterSpec defines the desired state of Plotter, which is applied in a multi-clustered environment. Plotter declares what needs to be installed and where (as blueprints running on remote clusters) which provides the Data Scientist's application with secure and governed access to the data requested in the FybrikApplication. Name Type Description Required appSelector object Selector enables to connect the resource to the application Application labels should match the labels in the selector. For some flows the selector may not be used. false assets map[string]object Assets is a map holding information about the assets The key is the assetID true flows []object true modulesNamespace string ModulesNamespace is the namespace where modules should be allocated true templates map[string]object Templates is a map holding the templates used in this plotter steps The key is the template name true Plotter.spec.appSelector \u21a9 Parent Selector enables to connect the resource to the application Application labels should match the labels in the selector. For some flows the selector may not be used. Name Type Description Required clusterName string Cluster name false workloadSelector object WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. true Plotter.spec.appSelector.workloadSelector \u21a9 Parent WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false Plotter.spec.appSelector.workloadSelector.matchExpressions[index] \u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true Plotter.spec.assets[key] \u21a9 Parent AssetDetails is a list of assets used in the fybrikapplication. In addition to assets declared in fybrikapplication, AssetDetails list also contains assets that are allocated by the control-plane in order to serve fybrikapplication Name Type Description Required advertisedAssetId string AdvertisedAssetID links this asset to asset from fybrikapplication and is used by user facing services false assetDetails object DataStore contains the details for accesing the data that are sent by catalog connectors Credentials for accesing the data are stored in Vault, in the location represented by Vault property. true Plotter.spec.assets[key].assetDetails \u21a9 Parent DataStore contains the details for accesing the data that are sent by catalog connectors Credentials for accesing the data are stored in Vault, in the location represented by Vault property. Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true Plotter.spec.assets[key].assetDetails.connection \u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true Plotter.spec.assets[key].assetDetails.vault[key] \u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true Plotter.spec.flows[index] \u21a9 Parent Flows is the list of data flows driven from fybrikapplication: Each element in the list holds the flow of the data requested in fybrikapplication. Name Type Description Required assetId string AssetID indicates the data set being used in this data flow true flowType string Type of the flow (e.g. read) true name string Name of the flow true subFlows []object true Plotter.spec.flows[index].subFlows[index] \u21a9 Parent Subflows is a list of data flows which are originated from the same data asset but are triggered differently (e.g., one upon init trigger and one upon workload trigger) Name Type Description Required flowType string Type of the flow (e.g. read) true name string Name of the SubFlow true steps [][]object Steps defines a series of sequential/parallel data flow steps The first dimension represents parallel data flows. The second sequential components within the same parallel data flow. true triggers []enum Triggers true Plotter.spec.flows[index].subFlows[index].steps[index][index] \u21a9 Parent DataFlowStep contains details on a single data flow step Name Type Description Required parameters object Step parameters TODO why not flatten the parameters into this data flow step false cluster string Name of the cluster this step is executed on true name string Name of the step true template string Template is the name of the template to execute the step The full details of the template can be extracted from Plotter.spec.templates list field. true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters \u21a9 Parent Step parameters TODO why not flatten the parameters into this data flow step Name Type Description Required action []object Actions are the data transformations that the module supports false api object ResourceDetails includes asset connection details false sink object StepSink holds information to where the target data will be written: it could be assetID of an asset specified in fybrikapplication or of an asset created by fybrik control-plane false source object StepSource is the source of this step: it could be assetID or an enpoint of another step false Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.action[index] \u21a9 Parent Name Type Description Required name string true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.api \u21a9 Parent ResourceDetails includes asset connection details Name Type Description Required dataFormat string Data format false connection object Connection information true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.api.connection \u21a9 Parent Connection information Name Type Description Required name string true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.sink \u21a9 Parent StepSink holds information to where the target data will be written: it could be assetID of an asset specified in fybrikapplication or of an asset created by fybrik control-plane Name Type Description Required assetId string AssetID identifies the target asset of this step true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source \u21a9 Parent StepSource is the source of this step: it could be assetID or an enpoint of another step Name Type Description Required api object API holds information for accessing a module instance false assetId string AssetID identifies the source asset of this step false Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source.api \u21a9 Parent API holds information for accessing a module instance Name Type Description Required dataFormat string Data format false connection object Connection information true Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source.api.connection \u21a9 Parent Connection information Name Type Description Required name string true Plotter.spec.templates[key] \u21a9 Parent Template contains basic information about the required modules to serve the fybrikapplication e.g., the module helm chart name. Name Type Description Required name string Name of the template false modules []object Modules is a list of dependent modules. e.g., if a plugin module is used then the service module is used in should appear first in the modules list of the same template. If the modules list contains more than one module, the first module in the list is referred to as the \"primary module\" of which all the parameters to this template are sent to. true Plotter.spec.templates[key].modules[index] \u21a9 Parent ModuleInfo is a copy of FybrikModule Custom Resource. It contains information to instantiate resource of type FybrikModule. Name Type Description Required scope enum Scope indicates at what level the capability is used: workload, asset, cluster If not indicated it is assumed to be asset Enum : asset, workload, cluster false chart object Chart contains the information needed to use helm to install the capability true name string Name of the module true type string May be one of service, config or plugin Service: Means that the control plane deploys the component that performs the capability Config: Another pre-installed service performs the capability and the module deployed configures it for the particular workload or dataset Plugin: Indicates that this module performs a capability as part of another service or module rather than as a stand-alone module true Plotter.spec.templates[key].modules[index].chart \u21a9 Parent Chart contains the information needed to use helm to install the capability Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true Plotter.status \u21a9 Parent PlotterStatus defines the observed state of Plotter This includes readiness, error message, and indicators received from blueprint resources owned by the Plotter for cleanup and status monitoring Name Type Description Required assets map[string]object Assets is a map containing the status per asset. The key of this map is assetId false blueprints map[string]object false conditions []object Conditions represent the possible error and failure conditions false flows map[string]object Flows is a map containing the status for each flow the key is the flow name false observedGeneration integer ObservedGeneration is taken from the Plotter metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated blueprints should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false readyTimestamp string Format : date-time false Plotter.status.assets[key] \u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Plotter.status.blueprints[key] \u21a9 Parent MetaBlueprint defines blueprint metadata (name, namespace) and status Name Type Description Required name string true namespace string true status object BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring true Plotter.status.blueprints[key].status \u21a9 Parent BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring Name Type Description Required modules map[string]object ModulesState is a map which holds the status of each module its key is the moduleInstanceName which is the unique name for the deployed instance related to this workload false observedGeneration integer ObservedGeneration is taken from the Blueprint metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated resources should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false releases map[string]integer Releases map each release to the observed generation of the blueprint containing this release. At the end of reconcile, each release should be mapped to the latest blueprint version or be uninstalled. false Plotter.status.blueprints[key].status.modules[key] \u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Plotter.status.blueprints[key].status.observedState \u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Plotter.status.conditions[index] \u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true Plotter.status.flows[key] \u21a9 Parent FlowStatus includes information to be reported back to the FybrikApplication resource It holds the status per data flow Name Type Description Required status object ObservedState includes information about the current flow It includes readiness and error indications, as well as user instructions false subFlows map[string]object true Plotter.status.flows[key].status \u21a9 Parent ObservedState includes information about the current flow It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Plotter.status.flows[key].subFlows[key] \u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false Plotter.status.observedState \u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false katalog.fybrik.io/v1alpha1 Resource Types: Asset Asset \u21a9 Parent Asset defines an asset in the catalog Name Type Description Required apiVersion string katalog.fybrik.io/v1alpha1 true kind string Asset true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object false Asset.spec \u21a9 Parent Name Type Description Required details object Asset details true metadata object Asset metadata true secretRef object Reference to a Secret resource holding credentials for this asset true Asset.spec.details \u21a9 Parent Asset details Name Type Description Required dataFormat string Data format false connection object Connection information true Asset.spec.details.connection \u21a9 Parent Connection information Name Type Description Required name string true Asset.spec.metadata \u21a9 Parent Asset metadata Name Type Description Required columns []object Columns associated with the asset false geography string Geography of the resource false owner string Owner of the resource false tags object Tags associated with the asset false name string Name of the resource true Asset.spec.metadata.columns[index] \u21a9 Parent ResourceColumn represents a column in a tabular resource Name Type Description Required tags object Tags associated with the column false name string Name of the column true Asset.spec.secretRef \u21a9 Parent Reference to a Secret resource holding credentials for this asset Name Type Description Required name string Name of the Secret resource (must exist in the same namespace) true","title":"API Reference"},{"location":"reference/crds/#api-reference","text":"Packages: app.fybrik.io/v1alpha1 katalog.fybrik.io/v1alpha1","title":"API Reference"},{"location":"reference/crds/#appfybrikiov1alpha1","text":"Resource Types: Blueprint FybrikApplication FybrikModule FybrikStorageAccount Plotter","title":"app.fybrik.io/v1alpha1"},{"location":"reference/crds/#blueprint","text":"\u21a9 Parent Blueprint is the Schema for the blueprints API Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string Blueprint true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object BlueprintSpec defines the desired state of Blueprint, which defines the components of the workload's data path that run in a particular cluster. In a single cluster environment there is one blueprint per workload (FybrikApplication). In a multi-cluster environment there is one Blueprint per cluster per workload (FybrikApplication). false status object BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring false","title":"Blueprint"},{"location":"reference/crds/#blueprintspec","text":"\u21a9 Parent BlueprintSpec defines the desired state of Blueprint, which defines the components of the workload's data path that run in a particular cluster. In a single cluster environment there is one blueprint per workload (FybrikApplication). In a multi-cluster environment there is one Blueprint per cluster per workload (FybrikApplication). Name Type Description Required cluster string Cluster indicates the cluster on which the Blueprint runs true modules map[string]object Modules is a map which contains modules that indicate the data path components that run in this cluster The map key is moduleInstanceName which is the unique name for the deployed instance related to this workload true modulesNamespace string ModulesNamespace is the namespace where modules should be allocated true","title":"Blueprint.spec"},{"location":"reference/crds/#blueprintspecmoduleskey","text":"\u21a9 Parent BlueprintModule is a copy of a FybrikModule Custom Resource. It contains the information necessary to instantiate a datapath component, including the parameters relevant for the particular workload. Name Type Description Required arguments object Arguments are the input parameters for a specific instance of a module. false assetIds []string assetIDs indicate the assets processed by this module. Included so we can track asset status as well as module status in the future. false chart object Chart contains the location of the helm chart with info detailing how to deploy true name string Name of the FybrikModule on which this is based true","title":"Blueprint.spec.modules[key]"},{"location":"reference/crds/#blueprintspecmoduleskeyarguments","text":"\u21a9 Parent Arguments are the input parameters for a specific instance of a module. Name Type Description Required appSelector object Application selector is used to identify the user workload. It is obtained from FybrikApplication spec. false copy object CopyArgs are parameters specific to modules that copy data from one data store to another. false labels map[string]string Labels of FybrikApplication false read []object ReadArgs are parameters that are specific to modules that enable an application to read data false write []object WriteArgs are parameters that are specific to modules that enable an application to write data false","title":"Blueprint.spec.modules[key].arguments"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsappselector","text":"\u21a9 Parent Application selector is used to identify the user workload. It is obtained from FybrikApplication spec. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false","title":"Blueprint.spec.modules[key].arguments.appSelector"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsappselectormatchexpressionsindex","text":"\u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true","title":"Blueprint.spec.modules[key].arguments.appSelector.matchExpressions[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopy","text":"\u21a9 Parent CopyArgs are parameters specific to modules that copy data from one data store to another. Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data as it is copied. false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true destination object Destination is the data store to which the data will be copied true source object Source is the where the data currently resides true","title":"Blueprint.spec.modules[key].arguments.copy"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopytransformationsindex","text":"\u21a9 Parent Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.copy.transformations[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopydestination","text":"\u21a9 Parent Destination is the data store to which the data will be copied Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true","title":"Blueprint.spec.modules[key].arguments.copy.destination"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopydestinationconnection","text":"\u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.copy.destination.connection"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopydestinationvaultkey","text":"\u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true","title":"Blueprint.spec.modules[key].arguments.copy.destination.vault[key]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopysource","text":"\u21a9 Parent Source is the where the data currently resides Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true","title":"Blueprint.spec.modules[key].arguments.copy.source"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopysourceconnection","text":"\u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.copy.source.connection"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentscopysourcevaultkey","text":"\u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true","title":"Blueprint.spec.modules[key].arguments.copy.source.vault[key]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsreadindex","text":"\u21a9 Parent ReadModuleArgs define the input parameters for modules that read data from location A Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true source object Source of the read path module true","title":"Blueprint.spec.modules[key].arguments.read[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsreadindextransformationsindex","text":"\u21a9 Parent Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.read[index].transformations[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsreadindexsource","text":"\u21a9 Parent Source of the read path module Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true","title":"Blueprint.spec.modules[key].arguments.read[index].source"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsreadindexsourceconnection","text":"\u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.read[index].source.connection"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentsreadindexsourcevaultkey","text":"\u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true","title":"Blueprint.spec.modules[key].arguments.read[index].source.vault[key]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentswriteindex","text":"\u21a9 Parent WriteModuleArgs define the input parameters for modules that write data to location B Name Type Description Required transformations []object Transformations are different types of processing that may be done to the data as it is written. false assetID string AssetID identifies the asset to be used for accessing the data when it is ready It is copied from the FybrikApplication resource true destination object Destination is the data store to which the data will be written true","title":"Blueprint.spec.modules[key].arguments.write[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentswriteindextransformationsindex","text":"\u21a9 Parent Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.write[index].transformations[index]"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentswriteindexdestination","text":"\u21a9 Parent Destination is the data store to which the data will be written Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true","title":"Blueprint.spec.modules[key].arguments.write[index].destination"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentswriteindexdestinationconnection","text":"\u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true","title":"Blueprint.spec.modules[key].arguments.write[index].destination.connection"},{"location":"reference/crds/#blueprintspecmoduleskeyargumentswriteindexdestinationvaultkey","text":"\u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true","title":"Blueprint.spec.modules[key].arguments.write[index].destination.vault[key]"},{"location":"reference/crds/#blueprintspecmoduleskeychart","text":"\u21a9 Parent Chart contains the location of the helm chart with info detailing how to deploy Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true","title":"Blueprint.spec.modules[key].chart"},{"location":"reference/crds/#blueprintstatus","text":"\u21a9 Parent BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring Name Type Description Required modules map[string]object ModulesState is a map which holds the status of each module its key is the moduleInstanceName which is the unique name for the deployed instance related to this workload false observedGeneration integer ObservedGeneration is taken from the Blueprint metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated resources should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false releases map[string]integer Releases map each release to the observed generation of the blueprint containing this release. At the end of reconcile, each release should be mapped to the latest blueprint version or be uninstalled. false","title":"Blueprint.status"},{"location":"reference/crds/#blueprintstatusmoduleskey","text":"\u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Blueprint.status.modules[key]"},{"location":"reference/crds/#blueprintstatusobservedstate","text":"\u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Blueprint.status.observedState"},{"location":"reference/crds/#fybrikapplication","text":"\u21a9 Parent FybrikApplication provides information about the application whose data is being operated on, the nature of the processing, and the data sets chosen for processing by the application. The FybrikApplication controller obtains instructions regarding any governance related changes that must be performed on the data, identifies the modules capable of performing such changes, and finally generates the Plotter which defines the secure runtime environment and all the components in it. This runtime environment provides the application with access to the data requested in a secure manner and without having to provide any credentials for the data sets. The credentials are obtained automatically by the manager from the credential management system. Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikApplication true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object FybrikApplicationSpec defines data flows needed by the application, the purpose and other contextual information about the application. Read flow - if selector is populated, fybrik builds a data plane for reading the specified data sets Ingest flow - if no selector, and data/copy/required is true then the data specified is copied into a bucket allocated by fybrik and is cataloged in the data catalog false status object FybrikApplicationStatus defines the observed state of FybrikApplication. false","title":"FybrikApplication"},{"location":"reference/crds/#fybrikapplicationspec","text":"\u21a9 Parent FybrikApplicationSpec defines data flows needed by the application, the purpose and other contextual information about the application. Read flow - if selector is populated, fybrik builds a data plane for reading the specified data sets Ingest flow - if no selector, and data/copy/required is true then the data specified is copied into a bucket allocated by fybrik and is cataloged in the data catalog Name Type Description Required secretRef string SecretRef points to the secret that holds credentials for each system the user has been authenticated with. The secret is deployed in FybrikApplication namespace. false selector object Selector enables to connect the resource to the application Application labels should match the labels in the selector. false appInfo map[string]string AppInfo contains information describing the reasons for the processing that will be done by the application. true data []object Data contains the identifiers of the data to be used by the Data Scientist's application, and the protocol used to access it and the format expected. true","title":"FybrikApplication.spec"},{"location":"reference/crds/#fybrikapplicationspecselector","text":"\u21a9 Parent Selector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required clusterName string Cluster name false workloadSelector object WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. true","title":"FybrikApplication.spec.selector"},{"location":"reference/crds/#fybrikapplicationspecselectorworkloadselector","text":"\u21a9 Parent WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false","title":"FybrikApplication.spec.selector.workloadSelector"},{"location":"reference/crds/#fybrikapplicationspecselectorworkloadselectormatchexpressionsindex","text":"\u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true","title":"FybrikApplication.spec.selector.workloadSelector.matchExpressions[index]"},{"location":"reference/crds/#fybrikapplicationspecdataindex","text":"\u21a9 Parent DataContext indicates data set chosen by the Data Scientist to be used by his application, and includes information about the data format and technologies used by the application to access the data. Name Type Description Required catalogService string CatalogService represents the catalog service for accessing the requested dataset. If not specified, the enterprise catalog service will be used. false dataSetID string DataSetID is a unique identifier of the dataset chosen from the data catalog for processing by the data user application. true requirements object Requirements from the system true","title":"FybrikApplication.spec.data[index]"},{"location":"reference/crds/#fybrikapplicationspecdataindexrequirements","text":"\u21a9 Parent Requirements from the system Name Type Description Required copy object CopyRequrements include the requirements for copying the data false interface object Interface indicates the protocol and format expected by the data user true","title":"FybrikApplication.spec.data[index].requirements"},{"location":"reference/crds/#fybrikapplicationspecdataindexrequirementscopy","text":"\u21a9 Parent CopyRequrements include the requirements for copying the data Name Type Description Required catalog object Catalog indicates that the data asset must be cataloged. false required boolean Required indicates that the data must be copied. false","title":"FybrikApplication.spec.data[index].requirements.copy"},{"location":"reference/crds/#fybrikapplicationspecdataindexrequirementscopycatalog","text":"\u21a9 Parent Catalog indicates that the data asset must be cataloged. Name Type Description Required catalogID string CatalogID specifies the catalog where the data will be cataloged. false service string CatalogService specifies the datacatalog service that will be used for catalogging the data into. false","title":"FybrikApplication.spec.data[index].requirements.copy.catalog"},{"location":"reference/crds/#fybrikapplicationspecdataindexrequirementsinterface","text":"\u21a9 Parent Interface indicates the protocol and format expected by the data user Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true","title":"FybrikApplication.spec.data[index].requirements.interface"},{"location":"reference/crds/#fybrikapplicationstatus","text":"\u21a9 Parent FybrikApplicationStatus defines the observed state of FybrikApplication. Name Type Description Required assetStates map[string]object AssetStates provides a status per asset false errorMessage string ErrorMessage indicates that an error has happened during the reconcile, unrelated to a specific asset false generated object Generated resource identifier false observedGeneration integer ObservedGeneration is taken from the FybrikApplication metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether the Blueprint status changed. Format : int64 false provisionedStorage map[string]object ProvisionedStorage maps a dataset (identified by AssetID) to the new provisioned bucket. It allows FybrikApplication controller to manage buckets in case the spec has been modified, an error has occurred, or a delete event has been received. ProvisionedStorage has the information required to register the dataset once the owned plotter resource is ready false ready boolean Ready is true if all specified assets are either ready to be used or are denied access. false validApplication string ValidApplication indicates whether the FybrikApplication is valid given the defined taxonomy false validatedGeneration integer ValidatedGeneration is the version of the FyrbikApplication that has been validated with the taxonomy defined. Format : int64 false","title":"FybrikApplication.status"},{"location":"reference/crds/#fybrikapplicationstatusassetstateskey","text":"\u21a9 Parent AssetState defines the observed state of an asset Name Type Description Required catalogedAsset string CatalogedAsset provides a new asset identifier after being registered in the enterprise catalog false conditions []object Conditions indicate the asset state (Ready, Deny, Error) false endpoint object Endpoint provides the endpoint spec from which the asset will be served to the application false","title":"FybrikApplication.status.assetStates[key]"},{"location":"reference/crds/#fybrikapplicationstatusassetstateskeyconditionsindex","text":"\u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true","title":"FybrikApplication.status.assetStates[key].conditions[index]"},{"location":"reference/crds/#fybrikapplicationstatusassetstateskeyendpoint","text":"\u21a9 Parent Endpoint provides the endpoint spec from which the asset will be served to the application Name Type Description Required name string true","title":"FybrikApplication.status.assetStates[key].endpoint"},{"location":"reference/crds/#fybrikapplicationstatusgenerated","text":"\u21a9 Parent Generated resource identifier Name Type Description Required appVersion integer Version of FybrikApplication that has generated this resource Format : int64 true kind string Kind of the resource (Blueprint, Plotter) true name string Name of the resource true namespace string Namespace of the resource true","title":"FybrikApplication.status.generated"},{"location":"reference/crds/#fybrikapplicationstatusprovisionedstoragekey","text":"\u21a9 Parent DatasetDetails holds details of the provisioned storage Name Type Description Required datasetRef string Reference to a Dataset resource containing the request to provision storage false secretRef string Reference to a secret where the credentials are stored false","title":"FybrikApplication.status.provisionedStorage[key]"},{"location":"reference/crds/#fybrikmodule","text":"\u21a9 Parent FybrikModule is a description of an injectable component. the parameters it requires, as well as the specification of how to instantiate such a component. It is used as metadata only. There is no status nor reconciliation. Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikModule true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true status object FybrikModuleStatus defines the observed state of FybrikModule. false spec object FybrikModuleSpec contains the info common to all modules, which are one of the components that process, load, write, audit, monitor the data used by the data scientist's application. true","title":"FybrikModule"},{"location":"reference/crds/#fybrikmodulestatus","text":"\u21a9 Parent FybrikModuleStatus defines the observed state of FybrikModule. Name Type Description Required conditions []object Conditions indicate the module states with respect to validation false","title":"FybrikModule.status"},{"location":"reference/crds/#fybrikmodulestatusconditionsindex","text":"\u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true","title":"FybrikModule.status.conditions[index]"},{"location":"reference/crds/#fybrikmodulespec","text":"\u21a9 Parent FybrikModuleSpec contains the info common to all modules, which are one of the components that process, load, write, audit, monitor the data used by the data scientist's application. Name Type Description Required dependencies []object Other components that must be installed in order for this module to work false description string An explanation of what this module does false pluginType string Plugin type indicates the plugin technology used to invoke the capabilities Ex: vault, fybrik-wasm... Should be provided if type is plugin false statusIndicators []object StatusIndicators allow to check status of a non-standard resource that can not be computed by helm/kstatus false capabilities []object Capabilities declares what this module knows how to do and the types of data it knows how to handle The key to the map is a CapabilityType string true chart object Reference to a Helm chart that allows deployment of the resources required for this module true type string May be one of service, config or plugin Service: Means that the control plane deploys the component that performs the capability Config: Another pre-installed service performs the capability and the module deployed configures it for the particular workload or dataset Plugin: Indicates that this module performs a capability as part of another service or module rather than as a stand-alone module true","title":"FybrikModule.spec"},{"location":"reference/crds/#fybrikmodulespecdependenciesindex","text":"\u21a9 Parent Dependency details another component on which this module relies - i.e. a pre-requisit Name Type Description Required name string Name is the name of the dependent component true type enum Type provides information used in determining how to instantiate the component Enum : module, connector, feature true","title":"FybrikModule.spec.dependencies[index]"},{"location":"reference/crds/#fybrikmodulespecstatusindicatorsindex","text":"\u21a9 Parent ResourceStatusIndicator is used to determine the status of an orchestrated resource Name Type Description Required errorMessage string ErrorMessage specifies the resource field to check for an error, e.g. status.errorMsg false failureCondition string FailureCondition specifies a condition that indicates the resource failure It uses kubernetes label selection syntax (https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) false kind string Kind provides information about the resource kind true successCondition string SuccessCondition specifies a condition that indicates that the resource is ready It uses kubernetes label selection syntax (https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) true","title":"FybrikModule.spec.statusIndicators[index]"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindex","text":"\u21a9 Parent Capability declares what this module knows how to do and the types of data it knows how to handle Name Type Description Required actions []object Actions are the data transformations that the module supports false api object API indicates to the application how to access the capabilities provided by the module false plugins []object Plugins enable the module to add libraries to perform actions rather than implementing them by itself false scope enum Scope indicates at what level the capability is used: workload, asset, cluster If not indicated it is assumed to be asset Enum : asset, workload, cluster false supportedInterfaces []object Copy should have one or more instances in the list, and its content should have source and sink Read should have one or more instances in the list, each with source populated Write should have one or more instances in the list, each with sink populated This field may not be required if not handling data false capability string Capability declares what this module knows how to do - ex: read, write, transform... true","title":"FybrikModule.spec.capabilities[index]"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexactionsindex","text":"\u21a9 Parent Name Type Description Required name string true","title":"FybrikModule.spec.capabilities[index].actions[index]"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexapi","text":"\u21a9 Parent API indicates to the application how to access the capabilities provided by the module Name Type Description Required dataFormat string Data format false connection object Connection information true","title":"FybrikModule.spec.capabilities[index].api"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexapiconnection","text":"\u21a9 Parent Connection information Name Type Description Required name string true","title":"FybrikModule.spec.capabilities[index].api.connection"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexpluginsindex","text":"\u21a9 Parent Name Type Description Required dataFormat string DataFormat indicates the format of data the plugin knows how to process true pluginType string PluginType indicates the technology used for the module and the plugin to interact The values supported should come from the module taxonomy Examples of such mechanisms are vault plugins, wasm, etc true","title":"FybrikModule.spec.capabilities[index].plugins[index]"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexsupportedinterfacesindex","text":"\u21a9 Parent ModuleInOut specifies the protocol and format of the data input and output by the module - if any Name Type Description Required sink object Sink specifies the output data protocol and format false source object Source specifies the input data protocol and format false","title":"FybrikModule.spec.capabilities[index].supportedInterfaces[index]"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexsupportedinterfacesindexsink","text":"\u21a9 Parent Sink specifies the output data protocol and format Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true","title":"FybrikModule.spec.capabilities[index].supportedInterfaces[index].sink"},{"location":"reference/crds/#fybrikmodulespeccapabilitiesindexsupportedinterfacesindexsource","text":"\u21a9 Parent Source specifies the input data protocol and format Name Type Description Required dataformat string DataFormat defines the data format type false protocol string Protocol defines the interface protocol used for data transactions true","title":"FybrikModule.spec.capabilities[index].supportedInterfaces[index].source"},{"location":"reference/crds/#fybrikmodulespecchart","text":"\u21a9 Parent Reference to a Helm chart that allows deployment of the resources required for this module Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true","title":"FybrikModule.spec.chart"},{"location":"reference/crds/#fybrikstorageaccount","text":"\u21a9 Parent FybrikStorageAccount defines a storage account used for copying data. Only S3 based storage is supported. It contains endpoint, region and a reference to the credentials a Owner of the asset is responsible to store the credentials Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string FybrikStorageAccount true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object FybrikStorageAccountSpec defines the desired state of FybrikStorageAccount false status object FybrikStorageAccountStatus defines the observed state of FybrikStorageAccount false","title":"FybrikStorageAccount"},{"location":"reference/crds/#fybrikstorageaccountspec","text":"\u21a9 Parent FybrikStorageAccountSpec defines the desired state of FybrikStorageAccount Name Type Description Required endpoints map[string]string Endpoints based on regions true id string Identification of a storage account true secretRef string A name of k8s secret deployed in the control plane. This secret includes secretKey and accessKey credentials for S3 bucket true","title":"FybrikStorageAccount.spec"},{"location":"reference/crds/#plotter","text":"\u21a9 Parent Plotter is the Schema for the plotters API Name Type Description Required apiVersion string app.fybrik.io/v1alpha1 true kind string Plotter true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object PlotterSpec defines the desired state of Plotter, which is applied in a multi-clustered environment. Plotter declares what needs to be installed and where (as blueprints running on remote clusters) which provides the Data Scientist's application with secure and governed access to the data requested in the FybrikApplication. false status object PlotterStatus defines the observed state of Plotter This includes readiness, error message, and indicators received from blueprint resources owned by the Plotter for cleanup and status monitoring false","title":"Plotter"},{"location":"reference/crds/#plotterspec","text":"\u21a9 Parent PlotterSpec defines the desired state of Plotter, which is applied in a multi-clustered environment. Plotter declares what needs to be installed and where (as blueprints running on remote clusters) which provides the Data Scientist's application with secure and governed access to the data requested in the FybrikApplication. Name Type Description Required appSelector object Selector enables to connect the resource to the application Application labels should match the labels in the selector. For some flows the selector may not be used. false assets map[string]object Assets is a map holding information about the assets The key is the assetID true flows []object true modulesNamespace string ModulesNamespace is the namespace where modules should be allocated true templates map[string]object Templates is a map holding the templates used in this plotter steps The key is the template name true","title":"Plotter.spec"},{"location":"reference/crds/#plotterspecappselector","text":"\u21a9 Parent Selector enables to connect the resource to the application Application labels should match the labels in the selector. For some flows the selector may not be used. Name Type Description Required clusterName string Cluster name false workloadSelector object WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. true","title":"Plotter.spec.appSelector"},{"location":"reference/crds/#plotterspecappselectorworkloadselector","text":"\u21a9 Parent WorkloadSelector enables to connect the resource to the application Application labels should match the labels in the selector. Name Type Description Required matchExpressions []object matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false","title":"Plotter.spec.appSelector.workloadSelector"},{"location":"reference/crds/#plotterspecappselectorworkloadselectormatchexpressionsindex","text":"\u21a9 Parent A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values. Name Type Description Required values []string values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false key string key is the label key that the selector applies to. true operator string operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true","title":"Plotter.spec.appSelector.workloadSelector.matchExpressions[index]"},{"location":"reference/crds/#plotterspecassetskey","text":"\u21a9 Parent AssetDetails is a list of assets used in the fybrikapplication. In addition to assets declared in fybrikapplication, AssetDetails list also contains assets that are allocated by the control-plane in order to serve fybrikapplication Name Type Description Required advertisedAssetId string AdvertisedAssetID links this asset to asset from fybrikapplication and is used by user facing services false assetDetails object DataStore contains the details for accesing the data that are sent by catalog connectors Credentials for accesing the data are stored in Vault, in the location represented by Vault property. true","title":"Plotter.spec.assets[key]"},{"location":"reference/crds/#plotterspecassetskeyassetdetails","text":"\u21a9 Parent DataStore contains the details for accesing the data that are sent by catalog connectors Credentials for accesing the data are stored in Vault, in the location represented by Vault property. Name Type Description Required format string Format represents data format (e.g. parquet) as received from catalog connectors false connection object Connection has the relevant details for accesing the data (url, table, ssl, etc.) true vault map[string]object Holds details for retrieving credentials by the modules from Vault store. It is a map so that different credentials can be stored for the different DataFlow operations. true","title":"Plotter.spec.assets[key].assetDetails"},{"location":"reference/crds/#plotterspecassetskeyassetdetailsconnection","text":"\u21a9 Parent Connection has the relevant details for accesing the data (url, table, ssl, etc.) Name Type Description Required name string true","title":"Plotter.spec.assets[key].assetDetails.connection"},{"location":"reference/crds/#plotterspecassetskeyassetdetailsvaultkey","text":"\u21a9 Parent Holds details for retrieving credentials from Vault store. Name Type Description Required address string Address is Vault address true authPath string AuthPath is the path to auth method i.e. kubernetes true role string Role is the Vault role used for retrieving the credentials true secretPath string SecretPath is the path of the secret holding the Credentials in Vault true","title":"Plotter.spec.assets[key].assetDetails.vault[key]"},{"location":"reference/crds/#plotterspecflowsindex","text":"\u21a9 Parent Flows is the list of data flows driven from fybrikapplication: Each element in the list holds the flow of the data requested in fybrikapplication. Name Type Description Required assetId string AssetID indicates the data set being used in this data flow true flowType string Type of the flow (e.g. read) true name string Name of the flow true subFlows []object true","title":"Plotter.spec.flows[index]"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindex","text":"\u21a9 Parent Subflows is a list of data flows which are originated from the same data asset but are triggered differently (e.g., one upon init trigger and one upon workload trigger) Name Type Description Required flowType string Type of the flow (e.g. read) true name string Name of the SubFlow true steps [][]object Steps defines a series of sequential/parallel data flow steps The first dimension represents parallel data flows. The second sequential components within the same parallel data flow. true triggers []enum Triggers true","title":"Plotter.spec.flows[index].subFlows[index]"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindex","text":"\u21a9 Parent DataFlowStep contains details on a single data flow step Name Type Description Required parameters object Step parameters TODO why not flatten the parameters into this data flow step false cluster string Name of the cluster this step is executed on true name string Name of the step true template string Template is the name of the template to execute the step The full details of the template can be extracted from Plotter.spec.templates list field. true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index]"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparameters","text":"\u21a9 Parent Step parameters TODO why not flatten the parameters into this data flow step Name Type Description Required action []object Actions are the data transformations that the module supports false api object ResourceDetails includes asset connection details false sink object StepSink holds information to where the target data will be written: it could be assetID of an asset specified in fybrikapplication or of an asset created by fybrik control-plane false source object StepSource is the source of this step: it could be assetID or an enpoint of another step false","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparametersactionindex","text":"\u21a9 Parent Name Type Description Required name string true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.action[index]"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparametersapi","text":"\u21a9 Parent ResourceDetails includes asset connection details Name Type Description Required dataFormat string Data format false connection object Connection information true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.api"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparametersapiconnection","text":"\u21a9 Parent Connection information Name Type Description Required name string true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.api.connection"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparameterssink","text":"\u21a9 Parent StepSink holds information to where the target data will be written: it could be assetID of an asset specified in fybrikapplication or of an asset created by fybrik control-plane Name Type Description Required assetId string AssetID identifies the target asset of this step true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.sink"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparameterssource","text":"\u21a9 Parent StepSource is the source of this step: it could be assetID or an enpoint of another step Name Type Description Required api object API holds information for accessing a module instance false assetId string AssetID identifies the source asset of this step false","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparameterssourceapi","text":"\u21a9 Parent API holds information for accessing a module instance Name Type Description Required dataFormat string Data format false connection object Connection information true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source.api"},{"location":"reference/crds/#plotterspecflowsindexsubflowsindexstepsindexindexparameterssourceapiconnection","text":"\u21a9 Parent Connection information Name Type Description Required name string true","title":"Plotter.spec.flows[index].subFlows[index].steps[index][index].parameters.source.api.connection"},{"location":"reference/crds/#plotterspectemplateskey","text":"\u21a9 Parent Template contains basic information about the required modules to serve the fybrikapplication e.g., the module helm chart name. Name Type Description Required name string Name of the template false modules []object Modules is a list of dependent modules. e.g., if a plugin module is used then the service module is used in should appear first in the modules list of the same template. If the modules list contains more than one module, the first module in the list is referred to as the \"primary module\" of which all the parameters to this template are sent to. true","title":"Plotter.spec.templates[key]"},{"location":"reference/crds/#plotterspectemplateskeymodulesindex","text":"\u21a9 Parent ModuleInfo is a copy of FybrikModule Custom Resource. It contains information to instantiate resource of type FybrikModule. Name Type Description Required scope enum Scope indicates at what level the capability is used: workload, asset, cluster If not indicated it is assumed to be asset Enum : asset, workload, cluster false chart object Chart contains the information needed to use helm to install the capability true name string Name of the module true type string May be one of service, config or plugin Service: Means that the control plane deploys the component that performs the capability Config: Another pre-installed service performs the capability and the module deployed configures it for the particular workload or dataset Plugin: Indicates that this module performs a capability as part of another service or module rather than as a stand-alone module true","title":"Plotter.spec.templates[key].modules[index]"},{"location":"reference/crds/#plotterspectemplateskeymodulesindexchart","text":"\u21a9 Parent Chart contains the information needed to use helm to install the capability Name Type Description Required chartPullSecret string Name of secret containing helm registry credentials false values map[string]string Values to pass to helm chart installation false name string Name of helm chart true","title":"Plotter.spec.templates[key].modules[index].chart"},{"location":"reference/crds/#plotterstatus","text":"\u21a9 Parent PlotterStatus defines the observed state of Plotter This includes readiness, error message, and indicators received from blueprint resources owned by the Plotter for cleanup and status monitoring Name Type Description Required assets map[string]object Assets is a map containing the status per asset. The key of this map is assetId false blueprints map[string]object false conditions []object Conditions represent the possible error and failure conditions false flows map[string]object Flows is a map containing the status for each flow the key is the flow name false observedGeneration integer ObservedGeneration is taken from the Plotter metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated blueprints should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false readyTimestamp string Format : date-time false","title":"Plotter.status"},{"location":"reference/crds/#plotterstatusassetskey","text":"\u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.assets[key]"},{"location":"reference/crds/#plotterstatusblueprintskey","text":"\u21a9 Parent MetaBlueprint defines blueprint metadata (name, namespace) and status Name Type Description Required name string true namespace string true status object BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring true","title":"Plotter.status.blueprints[key]"},{"location":"reference/crds/#plotterstatusblueprintskeystatus","text":"\u21a9 Parent BlueprintStatus defines the observed state of Blueprint This includes readiness, error message, and indicators for the Kubernetes resources owned by the Blueprint for cleanup and status monitoring Name Type Description Required modules map[string]object ModulesState is a map which holds the status of each module its key is the moduleInstanceName which is the unique name for the deployed instance related to this workload false observedGeneration integer ObservedGeneration is taken from the Blueprint metadata. This is used to determine during reconcile whether reconcile was called because the desired state changed, or whether status of the allocated resources should be checked. Format : int64 false observedState object ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions false releases map[string]integer Releases map each release to the observed generation of the blueprint containing this release. At the end of reconcile, each release should be mapped to the latest blueprint version or be uninstalled. false","title":"Plotter.status.blueprints[key].status"},{"location":"reference/crds/#plotterstatusblueprintskeystatusmoduleskey","text":"\u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.blueprints[key].status.modules[key]"},{"location":"reference/crds/#plotterstatusblueprintskeystatusobservedstate","text":"\u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.blueprints[key].status.observedState"},{"location":"reference/crds/#plotterstatusconditionsindex","text":"\u21a9 Parent Condition describes the state of a FybrikApplication at a certain point. Name Type Description Required message string Message contains the details of the current condition false observedGeneration integer ObservedGeneration is the version of the resource for which the condition has been evaluated Format : int64 false status enum Status of the condition, one of (`True`, `False`, `Unknown`). Enum : True, False, Unknown Default : Unknown false type string Type of the condition true","title":"Plotter.status.conditions[index]"},{"location":"reference/crds/#plotterstatusflowskey","text":"\u21a9 Parent FlowStatus includes information to be reported back to the FybrikApplication resource It holds the status per data flow Name Type Description Required status object ObservedState includes information about the current flow It includes readiness and error indications, as well as user instructions false subFlows map[string]object true","title":"Plotter.status.flows[key]"},{"location":"reference/crds/#plotterstatusflowskeystatus","text":"\u21a9 Parent ObservedState includes information about the current flow It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.flows[key].status"},{"location":"reference/crds/#plotterstatusflowskeysubflowskey","text":"\u21a9 Parent ObservedState represents a part of the generated Blueprint/Plotter resource status that allows update of FybrikApplication status Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.flows[key].subFlows[key]"},{"location":"reference/crds/#plotterstatusobservedstate","text":"\u21a9 Parent ObservedState includes information to be reported back to the FybrikApplication resource It includes readiness and error indications, as well as user instructions Name Type Description Required error string Error indicates that there has been an error to orchestrate the modules and provides the error message false ready boolean Ready represents that the modules have been orchestrated successfully and the data is ready for usage false","title":"Plotter.status.observedState"},{"location":"reference/crds/#katalogfybrikiov1alpha1","text":"Resource Types: Asset","title":"katalog.fybrik.io/v1alpha1"},{"location":"reference/crds/#asset","text":"\u21a9 Parent Asset defines an asset in the catalog Name Type Description Required apiVersion string katalog.fybrik.io/v1alpha1 true kind string Asset true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object false","title":"Asset"},{"location":"reference/crds/#assetspec","text":"\u21a9 Parent Name Type Description Required details object Asset details true metadata object Asset metadata true secretRef object Reference to a Secret resource holding credentials for this asset true","title":"Asset.spec"},{"location":"reference/crds/#assetspecdetails","text":"\u21a9 Parent Asset details Name Type Description Required dataFormat string Data format false connection object Connection information true","title":"Asset.spec.details"},{"location":"reference/crds/#assetspecdetailsconnection","text":"\u21a9 Parent Connection information Name Type Description Required name string true","title":"Asset.spec.details.connection"},{"location":"reference/crds/#assetspecmetadata","text":"\u21a9 Parent Asset metadata Name Type Description Required columns []object Columns associated with the asset false geography string Geography of the resource false owner string Owner of the resource false tags object Tags associated with the asset false name string Name of the resource true","title":"Asset.spec.metadata"},{"location":"reference/crds/#assetspecmetadatacolumnsindex","text":"\u21a9 Parent ResourceColumn represents a column in a tabular resource Name Type Description Required tags object Tags associated with the column false name string Name of the column true","title":"Asset.spec.metadata.columns[index]"},{"location":"reference/crds/#assetspecsecretref","text":"\u21a9 Parent Reference to a Secret resource holding credentials for this asset Name Type Description Required name string Name of the Secret resource (must exist in the same namespace) true","title":"Asset.spec.secretRef"},{"location":"reference/ddc/","text":"Data Distribution Controller Overview of Requirements and Functionality The Data Distribution Controller (DDC) handles the movement of data between data stores. Fybrik uses the DDC to perform an action called \"implicit copy\", i.e. the movement of a data set from one data store to another with possibly some unitary transform applied to that data set. It corresponds to Step 8 in the Architecture Document (Add a link here) Data can be copied from data store to data store in a large variety of different ways, depending on the types of the data store (e.g. COS, Relational DB) and nature of the data capture (Streamed, Snapshot). This document defines the functionality as well as the boundary conditions of the data distribution controller. Goals This document introduces fundamental concepts of the data distribution component and describes a high-level API for invoking data distributions. The initial focus is on structured (tabular) data. One goal of the data distribution component is to maximize congruence across different data stores and formats by preserving not only the data content but also the structure of the data as faithfully as possible. Fully unstructured data such (e.g. \"binary content\") will also be supported but that is not the focus of the initial version. Semi-structured data will be supported on a case-by-case basis. Non-Goals The focus is on how to invoke data distribution and not the if and when. This document doesn't describe the control component that is required to decide whether, when and how often data should be copied across storage systems. Neither does the data distribution perform any policy enforcement. This is done by the component that controls the data distribution system. High-Level Design Before providing an outline of the API functionality, some fundamental concepts are defined. Data Sets and Data Assets The following definition is aligned with the terminology used in the Watson Knowledge Catalog. Data is organized into data sets and data assets. A data set is a collection of data assets that is administered by a single body using a set of policies. Both data sets and data assets are uniquely identifiable. A data set is a collection of data assets with the same structure. Some examples: A data set is data that resides in a relational database where the database tables or views form the data asset. A data set consisting of objects that reside in a COS bucket where object prefix paths that have a common format are data assets. E.g. a set of partitioned parquet files with the same schema. A data set may be formed by a set of Kafka topics where each topic contains messages in compatible format. A data asset is represented by the content of the topic. The unit of data distribution is the data asset. Data Stores A data store allows access to data sets and data assets. Each store allows to individually access data through a data store specific API, e.g. S3 API or JDBC. Additional properties that are relevant for data distribution: Granularity of data access for reading: Some systems provide access to entire data assets only. (e.g. single unpartitioned files on COS). Other storage systems support queries to retrieve a sub-set (a selection and/or projection) of an individual data assets. (e.g. queries on Db2 or partitioned/bucketed prefixes on COS) Granularity of data access for writing: Fine-granular write access is required to apply delta-updates of individual data assets, i.e. update and insert ( upsert ) operations as well as deletes on record level are needed to process streams of changes. Systems that support fine-granular updates are relational database systems, elastic search indexes, and in-memory caches. Other systems such as traditional parquet files stored on COS or HDFS only allow data assets to be updated in their entirety. More sophisticated storage formats such as Delta Lake , Apache Iceberg or Hudi extend the capabilities of parquet. Fidelity of the type system: Data stores use various different typing systems and have different data models that require type conversions as data is distributed between these systems. For example, when moving the content of an elastic search index into a relational database we are moving between two entirely different data models. In order to minimize loss of information, type specific metadata (technical metadata) may need to be preserved as separate entities. In addition, schema inference might be needed to support certain data distributions. The invoker of the DDC is assumed to have knowledge of the technical metadata present at the source data asset and of the desired technical metadata of that data asset at the target. If the invoker does not specify this the DDC will attempt to infer it where possible. In both cases the source and target technical metadata are returned as part of the result of the data distribution. If the passed source or target technical metadata is inconsistent with the data asset at the source, then the data distribution fails. The version 1.0 of the DDC supports the following data stores: Db2 LUW v10.5 or newer Apache Kafka v2.2 or newer (Raw + Confluent KTable format serialized in JSON or Avro) IBM COS with Parquet, JSON and ORC (using a Stocator based approach) Transformations The data distribution supports simple transformations and filtering such as: - Filtering of individual rows or columns based on condition clauses. - Masking of specific columns. - Encrypting/hashing of specific columns. - Sampling of a subset of rows. This is specifically for creating a derived version of a specific data asset and is NOT to enrich or combine data assets, i.e. this is a not a general purpose computation environment. Data Life-cycle The DDC moves a data asset from a source to a target data store. The copy of the data asset will be retained at the target until explicitly removed by the invoker via the DDC API. API High-level Description The API follows the custom resource definition approach (CRD) for Kubernetes. The following basic CRD types exist: - BatchTransfer : One-time or periodic transfer of a single data asset from a source data store to a destination data store. This is also called snapshotting. This is similar to a job in K8s and will inherit many features from it, e.g. the state is kept in K8s after the batch transfer has completed and must be deleted manually. - SyncTransfer : Continuous synchronization of a single data asset from a source data store to a destination data store. The main use-case is to continuously update a destination data asset as it is typically used in a streaming or change-data-capture scenario. This CRD is similar to a stateful set in K8s. Both transfer types will have the same API concerning the core transfer definitions such as: - The source data store including connection details and data asset. - The path (in Vault) to the credentials required to access the source data store. - The destination data store including connection details and data asset. - The path (in Vault) to the credentials required to access the destination data store. - Transfer properties that define parameters such as schedule, retries, transformations etc. The difference is that SyncTransfer is running continuously, BatchTransfer requires a schedule or is a one-time transfer. Initially we will limit SyncTransfer to the movement of data from Kafka to COS or from Kafka to Db2. The status of the CRD is continuously updated with the state of the data distribution. It is used to detect both success or error situations as well as freshness. It also provides transfer statistics. Using the status of the CRD a user may examine: - where data assets have been moved - when this was last successfully completed (for _BatchTransfer_s) - statistics, i.e. how long this took, how many bytes, rows etc. were transferred - what technical metadata about the data was used at the source/destination Other K8s controllers can watch the objects and subscribe to statistics or technical metadata updates and forward these changes e.g. in dashboards or WKT. Secret management The data distribution API should not define any secrets in the CRD spec in a production environment. For development and testing direct definitions can be used but in a production environment credentials shall be retrieved from the secret provider. The secret provider can be accessed via a REST API using a role and a secret name. This secret name refers to a path in vault. At the movement operator shall not create any secrets in Kubernetes that contain any credentials and credentials shall only be maintained in memory. The fetching of secrets will be executed by the datamover component. The datamover component retrieves configuration from a JSON file that is passed on as a Kubernetes secret. The goal is that vault paths can be specified in this JSON configuration file and will be substituted by values retrieved from the secret provider. The following example illustrates this mechanism: Given the example configuration file: { \"db2URL\": \"jdbc:db2//host1:1234/MYDB\", \"user\": \"myuser\" \"vaultPath\": \"/myvault/db2Password\" } and the following string in vault: {\"password\": \"mypassword\"} The substitution in the datamover will find a JSON field called vaultPath and look up the value using the secret provider. The substitution happens at the same level as the vaultPath field was found. This works whenever the data that is stored in vault is a JSON object itself. The advantage is that the in-memory configuration will be the same as in a dev/test environment after the substitution. The result of the given example after substitution will be: { \"db2URL\": \"jdbc:db2//host1:1234/MYDB\", \"user\": \"myuser\" \"password\": \"mypassword\" } This credential substitution can also be used in the options field of transformations. Error handling The data distribution API is using validation hooks to do simple checks when a CRD is created or updated. This is a first kind of error that will result in an error when creating/updating the CRD. It will specify an error message about which fields are not valid. (e.g. an invalid cron pattern for the schedule property) As validation errors are checked before objects are created they return an error via the Kubernetes API. If an error occurred during a BatchTransfer the status of the CRD will be set to FAILED and a possible error reason will show in the error field. The error messages will differ depending on the type of exception that is thrown in the internal datamover process. The internal datamover process will communicate errors to Kubernetes via a termination message . The content of the termination message will be written into the error field of the BatchTransfer . The error message shall describe the error as good as possible without any stack traces to keep it readable and displayable in a short form. Actions for possible error states: * Pending - Nothing to do. Normal process * Running - Nothing to do. Normal process * Succeeded - Possibly execute on succeeded actions (e.g. updating a catalog, ...) * Failed - Operator will try to recover. * Fatal - Operator could not recover. Possibly recreate CRD to resolve and investigate error further. Events In addition to errors the datamover application that is called by the data distribution api will publish Kubernetes events for the CRD in order to give feedback for errors and successes. Errors will contain the error message. Successful messages will contain additional metrics such as number of transferred rows or technical metadata information. API Specification The formalism to use to describe this is to be decided, possibilities are Go using kubebuilder OR CRD directly. As the definition of transfer specific parameters is the same for BatchTransfer kind and SyncTransfer kind the definition below focusses on the BatchTransfer kind. (Think of it like a pod template definition that is the same for a job or a deployment) A possible but not complete list of Go structs using kubebuilder is: // BatchTransferSpec defines the desired state of BatchTransfer type BatchTransferSpec struct { Source DataStore `json:\"source\"` Destination DataStore `json:\"destination\"` Transformation []Transformation `json:\"transformation,omitempty\"` Schedule string `json:\"schedule,omitempty\"` Image string `json:\"image\"` // Has default value from webhook ImagePullPolicy corev1.PullPolicy `json:\"imagePullPolicy\"` // Has default value from webhook SecretProviderURL string `json:\"secretProviderURL\"` // Has default value from webhook SecretProviderRole string `json:\"secretProviderRole\"` // Has default value from webhook Suspend bool `json:\"suspend,omitempty\"` // Has default value from webhook MaxFailedRetries int `json:\"maxFailedRetries,omitempty\"` // Has default value from webhook SuccessfulJobHistoryLimit int `json:\"successfulJobHistoryLimit,omitempty\"` // Has default value from webhook FailedJobHistoryLimit int `json:\"failedJobHistoryLimit,omitempty\"` // Has default value from webhook } type DataStore struct { DataAsset string `json:\"dataAsset\"` Database *Database `json:\"database,omitempty\"` S3 *S3 `json:\"s3,omitempty\"` Kafka *Kafka `json:\"kafka,omitempty\"` } type Database struct { Db2URL string `json:\"db2URL\"` User string `json:\"user\"` Password *string `json:\"password,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` } type S3 struct { Endpoint string `json:\"endpoint\"` Region string `json:\"region,omitempty\"` Bucket string `json:\"bucket\"` AccessKey *string `json:\"accessKey,omitempty\"` // Please use for dev/test only! SecretKey *string `json:\"secretKey,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` ObjectKey string `json:\"objectKey\"` DataFormat string `json:\"dataFormat,omitempty\"` } type Kafka struct { KafkaBrokers string `json:\"kafkaBrokers\"` SchemaRegistryURL string `json:\"schemaRegistryURL\"` User string `json:\"user\"` Password *string `json:\"password,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` SslTruststoreLocation string `json:\"sslTruststoreLocation,omitempty\"` SslTruststorePassword string `json:\"sslTruststorePassword,omitempty\"` KafkaTopic string `json:\"kafkaTopic\"` CreateSnapshot bool `json:\"createSnapshot,omitempty\"` } type Transformation struct { Name string `json:\"name,omitempty\"` Action Action `json:\"action,omitempty\"` Columns []string `json:\"columns,omitempty\"` Options map[string]string `json:\"options,omitempty\"` } type Action string const ( RemoveColumn Action = \"RemoveColumn\" Filter Action = \"Filter\" Encrypt Action = \"Encrypt\" Sample Action = \"Sample\" Digest Action = \"Digest\" // md5, sha1, crc32, sha256, sha512, xxhash32, xxhash64, murmur32 Redact Action = \"Redact\" // random, fixed, formatted, etc ) // BatchTransferStatus defines the observed state of BatchTransfer type BatchTransferStatus struct { Active *corev1.ObjectReference `json:\"active,omitempty\"` Status Status `json:\"status,omitempty\"` Error string `json:\"status,omitempty\"` LastCompleted *corev1.ObjectReference `json:\"lastCompleted,omitempty\"` LastFailed *corev1.ObjectReference `json:\"lastFailed,omitempty\"` LastSuccessTime *metav1.Time `json:\"lastSuccessTime,omitempty\"` LastRecordTime *metav1.Time `json:\"lastRecordTime,omitempty\"` NumRecords int64 `json:\"numRecords,omitempty\"` LastScheduleTime *metav1.Time `json:\"lastScheduleTime,omitempty\"` } // +kubebuilder:validation:Enum=Pending;Running;Succeeded;Failed;Fatal;ConfigurationError type Status string const ( Pending Status = \"Pending\" // Starting up transfers Running Status = \"Running\" // Transfers are running Succeeded Status = \"Succeeded\" // Transfers succeeded Failed Status = \"Failed\" // Transfers failed (Maybe recoverable (e.g. temporary connection issues)) Fatal Status = \"Fatal\" // Fatal. Cannot recover. Manual intervention needed ) // +kubebuilder:object:root=true // BatchTransfer is the Schema for the batchtransfers API type BatchTransfer struct { metav1.TypeMeta `json:\",inline\"` metav1.ObjectMeta `json:\"metadata,omitempty\"` Spec BatchTransferSpec `json:\"spec,omitempty\"` Status BatchTransferStatus `json:\"status,omitempty\"` } // +kubebuilder:object:root=true // BatchTransferList contains a list of BatchTransfer type BatchTransferList struct { metav1.TypeMeta `json:\",inline\"` metav1.ListMeta `json:\"metadata,omitempty\"` Assets []BatchTransfer `json:\"assets\"` } Examples --- apiVersion: \"fybrik.io/v1\" kind: BatchTransfer metadata: name: copy1 namespace: myNamespace spec: source: db: db2URL: \"jdbc:db2://db1.psvc-dev.zc2.ibm.com:50602/DHUBS:sslConnection=true;\" user: myuser password: \"mypassword\" destination: cos: endpoint: s3... bucket: myBucket accessKey: 0123 secretKey: 0123 transformation: - name: \"Remove column A\" action: \"RemoveColumn\" columns: [\"A\"] - name: \"Digest column B\" action: \"Digest\" columns: [\"B\"] options: algo: \"md5\" schedule: null # Cron schedule definition if needed maxFailedRetries: 3 # Maximum retries if failed suspend: false successfulJobsHistoryLimit: 2 failedJobsHistoryLimit: 5 status: lastCompleted: corev1.ObjectReference # Reference to child K8s objects lastScheduledTime: 2018-01-01T00:00:00Z lastSuccessTime: 2018-01-01T00:00:00Z lastRecordTime: 2018-01-01T00:00:00Z # inspect data? numRecords: 23113 External Dependencies Data distribution will be implemented in different ways, depending on the distribution kind, on the source and destination data store technologies as well as depending on the requested transformations. The control layer of the data distribution is implemented following the operator pattern of Kubernetes. In addition, the following technologies are relevant for specific distribution scenarios: - Redhat Debezium for Change Data Capture - IBM Event Streams (Apache Kafka) for SyncTransfer - Apache Spark - Db2 client - COS client - Reference to IBM Specific JDBC driver for streaming into a relation database. Relevant Code Repositories The data distribution core libraries that are Scala/Spark based The data distribution operator has been integrated into Fybrik code and is part of the manager. Roadmap Integration with Parquet Encryption + KeyProtect (As Target) Integration with Iceberg (As Target) Integration with Relational Databases (As Target) Integration with KTables (As Source)","title":"Data Distribution Controller"},{"location":"reference/ddc/#data-distribution-controller","text":"","title":"Data Distribution Controller"},{"location":"reference/ddc/#overview-of-requirements-and-functionality","text":"The Data Distribution Controller (DDC) handles the movement of data between data stores. Fybrik uses the DDC to perform an action called \"implicit copy\", i.e. the movement of a data set from one data store to another with possibly some unitary transform applied to that data set. It corresponds to Step 8 in the Architecture Document (Add a link here) Data can be copied from data store to data store in a large variety of different ways, depending on the types of the data store (e.g. COS, Relational DB) and nature of the data capture (Streamed, Snapshot). This document defines the functionality as well as the boundary conditions of the data distribution controller.","title":"Overview of Requirements and Functionality"},{"location":"reference/ddc/#goals","text":"This document introduces fundamental concepts of the data distribution component and describes a high-level API for invoking data distributions. The initial focus is on structured (tabular) data. One goal of the data distribution component is to maximize congruence across different data stores and formats by preserving not only the data content but also the structure of the data as faithfully as possible. Fully unstructured data such (e.g. \"binary content\") will also be supported but that is not the focus of the initial version. Semi-structured data will be supported on a case-by-case basis.","title":"Goals"},{"location":"reference/ddc/#non-goals","text":"The focus is on how to invoke data distribution and not the if and when. This document doesn't describe the control component that is required to decide whether, when and how often data should be copied across storage systems. Neither does the data distribution perform any policy enforcement. This is done by the component that controls the data distribution system.","title":"Non-Goals"},{"location":"reference/ddc/#high-level-design","text":"Before providing an outline of the API functionality, some fundamental concepts are defined.","title":"High-Level Design"},{"location":"reference/ddc/#data-sets-and-data-assets","text":"The following definition is aligned with the terminology used in the Watson Knowledge Catalog. Data is organized into data sets and data assets. A data set is a collection of data assets that is administered by a single body using a set of policies. Both data sets and data assets are uniquely identifiable. A data set is a collection of data assets with the same structure. Some examples: A data set is data that resides in a relational database where the database tables or views form the data asset. A data set consisting of objects that reside in a COS bucket where object prefix paths that have a common format are data assets. E.g. a set of partitioned parquet files with the same schema. A data set may be formed by a set of Kafka topics where each topic contains messages in compatible format. A data asset is represented by the content of the topic. The unit of data distribution is the data asset.","title":"Data Sets and Data Assets"},{"location":"reference/ddc/#data-stores","text":"A data store allows access to data sets and data assets. Each store allows to individually access data through a data store specific API, e.g. S3 API or JDBC. Additional properties that are relevant for data distribution: Granularity of data access for reading: Some systems provide access to entire data assets only. (e.g. single unpartitioned files on COS). Other storage systems support queries to retrieve a sub-set (a selection and/or projection) of an individual data assets. (e.g. queries on Db2 or partitioned/bucketed prefixes on COS) Granularity of data access for writing: Fine-granular write access is required to apply delta-updates of individual data assets, i.e. update and insert ( upsert ) operations as well as deletes on record level are needed to process streams of changes. Systems that support fine-granular updates are relational database systems, elastic search indexes, and in-memory caches. Other systems such as traditional parquet files stored on COS or HDFS only allow data assets to be updated in their entirety. More sophisticated storage formats such as Delta Lake , Apache Iceberg or Hudi extend the capabilities of parquet. Fidelity of the type system: Data stores use various different typing systems and have different data models that require type conversions as data is distributed between these systems. For example, when moving the content of an elastic search index into a relational database we are moving between two entirely different data models. In order to minimize loss of information, type specific metadata (technical metadata) may need to be preserved as separate entities. In addition, schema inference might be needed to support certain data distributions. The invoker of the DDC is assumed to have knowledge of the technical metadata present at the source data asset and of the desired technical metadata of that data asset at the target. If the invoker does not specify this the DDC will attempt to infer it where possible. In both cases the source and target technical metadata are returned as part of the result of the data distribution. If the passed source or target technical metadata is inconsistent with the data asset at the source, then the data distribution fails. The version 1.0 of the DDC supports the following data stores: Db2 LUW v10.5 or newer Apache Kafka v2.2 or newer (Raw + Confluent KTable format serialized in JSON or Avro) IBM COS with Parquet, JSON and ORC (using a Stocator based approach)","title":"Data Stores"},{"location":"reference/ddc/#transformations","text":"The data distribution supports simple transformations and filtering such as: - Filtering of individual rows or columns based on condition clauses. - Masking of specific columns. - Encrypting/hashing of specific columns. - Sampling of a subset of rows. This is specifically for creating a derived version of a specific data asset and is NOT to enrich or combine data assets, i.e. this is a not a general purpose computation environment.","title":"Transformations"},{"location":"reference/ddc/#data-life-cycle","text":"The DDC moves a data asset from a source to a target data store. The copy of the data asset will be retained at the target until explicitly removed by the invoker via the DDC API.","title":"Data Life-cycle"},{"location":"reference/ddc/#api-high-level-description","text":"The API follows the custom resource definition approach (CRD) for Kubernetes. The following basic CRD types exist: - BatchTransfer : One-time or periodic transfer of a single data asset from a source data store to a destination data store. This is also called snapshotting. This is similar to a job in K8s and will inherit many features from it, e.g. the state is kept in K8s after the batch transfer has completed and must be deleted manually. - SyncTransfer : Continuous synchronization of a single data asset from a source data store to a destination data store. The main use-case is to continuously update a destination data asset as it is typically used in a streaming or change-data-capture scenario. This CRD is similar to a stateful set in K8s. Both transfer types will have the same API concerning the core transfer definitions such as: - The source data store including connection details and data asset. - The path (in Vault) to the credentials required to access the source data store. - The destination data store including connection details and data asset. - The path (in Vault) to the credentials required to access the destination data store. - Transfer properties that define parameters such as schedule, retries, transformations etc. The difference is that SyncTransfer is running continuously, BatchTransfer requires a schedule or is a one-time transfer. Initially we will limit SyncTransfer to the movement of data from Kafka to COS or from Kafka to Db2. The status of the CRD is continuously updated with the state of the data distribution. It is used to detect both success or error situations as well as freshness. It also provides transfer statistics. Using the status of the CRD a user may examine: - where data assets have been moved - when this was last successfully completed (for _BatchTransfer_s) - statistics, i.e. how long this took, how many bytes, rows etc. were transferred - what technical metadata about the data was used at the source/destination Other K8s controllers can watch the objects and subscribe to statistics or technical metadata updates and forward these changes e.g. in dashboards or WKT.","title":"API High-level Description"},{"location":"reference/ddc/#secret-management","text":"The data distribution API should not define any secrets in the CRD spec in a production environment. For development and testing direct definitions can be used but in a production environment credentials shall be retrieved from the secret provider. The secret provider can be accessed via a REST API using a role and a secret name. This secret name refers to a path in vault. At the movement operator shall not create any secrets in Kubernetes that contain any credentials and credentials shall only be maintained in memory. The fetching of secrets will be executed by the datamover component. The datamover component retrieves configuration from a JSON file that is passed on as a Kubernetes secret. The goal is that vault paths can be specified in this JSON configuration file and will be substituted by values retrieved from the secret provider. The following example illustrates this mechanism: Given the example configuration file: { \"db2URL\": \"jdbc:db2//host1:1234/MYDB\", \"user\": \"myuser\" \"vaultPath\": \"/myvault/db2Password\" } and the following string in vault: {\"password\": \"mypassword\"} The substitution in the datamover will find a JSON field called vaultPath and look up the value using the secret provider. The substitution happens at the same level as the vaultPath field was found. This works whenever the data that is stored in vault is a JSON object itself. The advantage is that the in-memory configuration will be the same as in a dev/test environment after the substitution. The result of the given example after substitution will be: { \"db2URL\": \"jdbc:db2//host1:1234/MYDB\", \"user\": \"myuser\" \"password\": \"mypassword\" } This credential substitution can also be used in the options field of transformations.","title":"Secret management"},{"location":"reference/ddc/#error-handling","text":"The data distribution API is using validation hooks to do simple checks when a CRD is created or updated. This is a first kind of error that will result in an error when creating/updating the CRD. It will specify an error message about which fields are not valid. (e.g. an invalid cron pattern for the schedule property) As validation errors are checked before objects are created they return an error via the Kubernetes API. If an error occurred during a BatchTransfer the status of the CRD will be set to FAILED and a possible error reason will show in the error field. The error messages will differ depending on the type of exception that is thrown in the internal datamover process. The internal datamover process will communicate errors to Kubernetes via a termination message . The content of the termination message will be written into the error field of the BatchTransfer . The error message shall describe the error as good as possible without any stack traces to keep it readable and displayable in a short form. Actions for possible error states: * Pending - Nothing to do. Normal process * Running - Nothing to do. Normal process * Succeeded - Possibly execute on succeeded actions (e.g. updating a catalog, ...) * Failed - Operator will try to recover. * Fatal - Operator could not recover. Possibly recreate CRD to resolve and investigate error further.","title":"Error handling"},{"location":"reference/ddc/#events","text":"In addition to errors the datamover application that is called by the data distribution api will publish Kubernetes events for the CRD in order to give feedback for errors and successes. Errors will contain the error message. Successful messages will contain additional metrics such as number of transferred rows or technical metadata information.","title":"Events"},{"location":"reference/ddc/#api-specification","text":"The formalism to use to describe this is to be decided, possibilities are Go using kubebuilder OR CRD directly. As the definition of transfer specific parameters is the same for BatchTransfer kind and SyncTransfer kind the definition below focusses on the BatchTransfer kind. (Think of it like a pod template definition that is the same for a job or a deployment) A possible but not complete list of Go structs using kubebuilder is: // BatchTransferSpec defines the desired state of BatchTransfer type BatchTransferSpec struct { Source DataStore `json:\"source\"` Destination DataStore `json:\"destination\"` Transformation []Transformation `json:\"transformation,omitempty\"` Schedule string `json:\"schedule,omitempty\"` Image string `json:\"image\"` // Has default value from webhook ImagePullPolicy corev1.PullPolicy `json:\"imagePullPolicy\"` // Has default value from webhook SecretProviderURL string `json:\"secretProviderURL\"` // Has default value from webhook SecretProviderRole string `json:\"secretProviderRole\"` // Has default value from webhook Suspend bool `json:\"suspend,omitempty\"` // Has default value from webhook MaxFailedRetries int `json:\"maxFailedRetries,omitempty\"` // Has default value from webhook SuccessfulJobHistoryLimit int `json:\"successfulJobHistoryLimit,omitempty\"` // Has default value from webhook FailedJobHistoryLimit int `json:\"failedJobHistoryLimit,omitempty\"` // Has default value from webhook } type DataStore struct { DataAsset string `json:\"dataAsset\"` Database *Database `json:\"database,omitempty\"` S3 *S3 `json:\"s3,omitempty\"` Kafka *Kafka `json:\"kafka,omitempty\"` } type Database struct { Db2URL string `json:\"db2URL\"` User string `json:\"user\"` Password *string `json:\"password,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` } type S3 struct { Endpoint string `json:\"endpoint\"` Region string `json:\"region,omitempty\"` Bucket string `json:\"bucket\"` AccessKey *string `json:\"accessKey,omitempty\"` // Please use for dev/test only! SecretKey *string `json:\"secretKey,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` ObjectKey string `json:\"objectKey\"` DataFormat string `json:\"dataFormat,omitempty\"` } type Kafka struct { KafkaBrokers string `json:\"kafkaBrokers\"` SchemaRegistryURL string `json:\"schemaRegistryURL\"` User string `json:\"user\"` Password *string `json:\"password,omitempty\"` // Please use for dev/test only! VaultPath *string `json:\"vaultPath,omitempty\"` SslTruststoreLocation string `json:\"sslTruststoreLocation,omitempty\"` SslTruststorePassword string `json:\"sslTruststorePassword,omitempty\"` KafkaTopic string `json:\"kafkaTopic\"` CreateSnapshot bool `json:\"createSnapshot,omitempty\"` } type Transformation struct { Name string `json:\"name,omitempty\"` Action Action `json:\"action,omitempty\"` Columns []string `json:\"columns,omitempty\"` Options map[string]string `json:\"options,omitempty\"` } type Action string const ( RemoveColumn Action = \"RemoveColumn\" Filter Action = \"Filter\" Encrypt Action = \"Encrypt\" Sample Action = \"Sample\" Digest Action = \"Digest\" // md5, sha1, crc32, sha256, sha512, xxhash32, xxhash64, murmur32 Redact Action = \"Redact\" // random, fixed, formatted, etc ) // BatchTransferStatus defines the observed state of BatchTransfer type BatchTransferStatus struct { Active *corev1.ObjectReference `json:\"active,omitempty\"` Status Status `json:\"status,omitempty\"` Error string `json:\"status,omitempty\"` LastCompleted *corev1.ObjectReference `json:\"lastCompleted,omitempty\"` LastFailed *corev1.ObjectReference `json:\"lastFailed,omitempty\"` LastSuccessTime *metav1.Time `json:\"lastSuccessTime,omitempty\"` LastRecordTime *metav1.Time `json:\"lastRecordTime,omitempty\"` NumRecords int64 `json:\"numRecords,omitempty\"` LastScheduleTime *metav1.Time `json:\"lastScheduleTime,omitempty\"` } // +kubebuilder:validation:Enum=Pending;Running;Succeeded;Failed;Fatal;ConfigurationError type Status string const ( Pending Status = \"Pending\" // Starting up transfers Running Status = \"Running\" // Transfers are running Succeeded Status = \"Succeeded\" // Transfers succeeded Failed Status = \"Failed\" // Transfers failed (Maybe recoverable (e.g. temporary connection issues)) Fatal Status = \"Fatal\" // Fatal. Cannot recover. Manual intervention needed ) // +kubebuilder:object:root=true // BatchTransfer is the Schema for the batchtransfers API type BatchTransfer struct { metav1.TypeMeta `json:\",inline\"` metav1.ObjectMeta `json:\"metadata,omitempty\"` Spec BatchTransferSpec `json:\"spec,omitempty\"` Status BatchTransferStatus `json:\"status,omitempty\"` } // +kubebuilder:object:root=true // BatchTransferList contains a list of BatchTransfer type BatchTransferList struct { metav1.TypeMeta `json:\",inline\"` metav1.ListMeta `json:\"metadata,omitempty\"` Assets []BatchTransfer `json:\"assets\"` }","title":"API Specification"},{"location":"reference/ddc/#examples","text":"--- apiVersion: \"fybrik.io/v1\" kind: BatchTransfer metadata: name: copy1 namespace: myNamespace spec: source: db: db2URL: \"jdbc:db2://db1.psvc-dev.zc2.ibm.com:50602/DHUBS:sslConnection=true;\" user: myuser password: \"mypassword\" destination: cos: endpoint: s3... bucket: myBucket accessKey: 0123 secretKey: 0123 transformation: - name: \"Remove column A\" action: \"RemoveColumn\" columns: [\"A\"] - name: \"Digest column B\" action: \"Digest\" columns: [\"B\"] options: algo: \"md5\" schedule: null # Cron schedule definition if needed maxFailedRetries: 3 # Maximum retries if failed suspend: false successfulJobsHistoryLimit: 2 failedJobsHistoryLimit: 5 status: lastCompleted: corev1.ObjectReference # Reference to child K8s objects lastScheduledTime: 2018-01-01T00:00:00Z lastSuccessTime: 2018-01-01T00:00:00Z lastRecordTime: 2018-01-01T00:00:00Z # inspect data? numRecords: 23113","title":"Examples"},{"location":"reference/ddc/#external-dependencies","text":"Data distribution will be implemented in different ways, depending on the distribution kind, on the source and destination data store technologies as well as depending on the requested transformations. The control layer of the data distribution is implemented following the operator pattern of Kubernetes. In addition, the following technologies are relevant for specific distribution scenarios: - Redhat Debezium for Change Data Capture - IBM Event Streams (Apache Kafka) for SyncTransfer - Apache Spark - Db2 client - COS client - Reference to IBM Specific JDBC driver for streaming into a relation database.","title":"External Dependencies"},{"location":"reference/ddc/#relevant-code-repositories","text":"The data distribution core libraries that are Scala/Spark based The data distribution operator has been integrated into Fybrik code and is part of the manager.","title":"Relevant Code Repositories"},{"location":"reference/ddc/#roadmap","text":"Integration with Parquet Encryption + KeyProtect (As Target) Integration with Iceberg (As Target) Integration with Relational Databases (As Target) Integration with KTables (As Source)","title":"Roadmap"},{"location":"reference/katalog/","text":"Katalog Katalog is a data catalog that is included in Fybrik for evaluation purposes. It is powered by Kubernetes resources: Asset CRD for managing data assets Secret resources for managing data access credentials Usage An Asset CRD includes a reference to a credentials Secret , connection information, and other metadata such as columns and associated security tags. Apply it like any other Kubernetes resource. Access credenditals are stored in Kubernetes Secret resources. You can use Basic authentication secrets or Opaque secrets with the following keys: Name Type Description Required access_key string Access key also known as AccessKeyId false secret_key string Secret key also known as SecretAccessKey false api_key string API key used in various IAM enabled services false password string Password for basic authentication false username string Username for basic authentication false Manage users Kubernetes RBAC is used for user management: To view Asset resources a Kubernetes user must be granted the katalog-viewer cluster role. To manage Asset resources a Kubernetes user must be granted the katalog-editor cluster role. As always, create a RoleBinding to grant these permissions to assets in a specific namespace and a ClusterRoleBinding to grant these premissions cluster wide.","title":"Katalog"},{"location":"reference/katalog/#katalog","text":"Katalog is a data catalog that is included in Fybrik for evaluation purposes. It is powered by Kubernetes resources: Asset CRD for managing data assets Secret resources for managing data access credentials","title":"Katalog"},{"location":"reference/katalog/#usage","text":"An Asset CRD includes a reference to a credentials Secret , connection information, and other metadata such as columns and associated security tags. Apply it like any other Kubernetes resource. Access credenditals are stored in Kubernetes Secret resources. You can use Basic authentication secrets or Opaque secrets with the following keys: Name Type Description Required access_key string Access key also known as AccessKeyId false secret_key string Secret key also known as SecretAccessKey false api_key string API key used in various IAM enabled services false password string Password for basic authentication false username string Username for basic authentication false","title":"Usage"},{"location":"reference/katalog/#manage-users","text":"Kubernetes RBAC is used for user management: To view Asset resources a Kubernetes user must be granted the katalog-viewer cluster role. To manage Asset resources a Kubernetes user must be granted the katalog-editor cluster role. As always, create a RoleBinding to grant these permissions to assets in a specific namespace and a ClusterRoleBinding to grant these premissions cluster wide.","title":"Manage users"},{"location":"samples/dashboard-sample/","text":"Dashboard sample This sample shows how Fybrik enables a dashboard application to display data from a backend REST server and displaying only compliant information with the person operating the dashboard. In the sample we show how a Fybrik module that support REST protocol can control what information is displayed in the dashboard through policies. Specifically in this sample we demonstrate: - Just in time policy decisions - A Fybrik module that supports REST API Note: At this time some features in this demo use mocks as some underlying support in Fybrik is still pending. About the dashboard application The dashboard application here is based on the smart manufacturing use-case of the European Horizon 2020 research project Fogprotect . Details for the use case are available here . The dashboard included in this sample is a mock dashboard of a remote manufacturing factory which can be controlled/supervised by expert operators from remote, without the need for the expert operator to be physically present in the factory. The scenario here is simplified for the purpose of this sample and demonstrates the following scenario: 1. A manufacturing robot that operates the manufacturing facility which can be activated or stopped remotely. 2. A safety dashboard observing the manufacturing floor which is composed of two areas. A production and a non-production area, that are observed by a video camera with image processing which monitors and counts the number of employees with and without helmets in each area. This is called the safety data of the factory. We demonstrate Fybrik abilities to control what data is seen by each role. In this scenario we show the following roles: 1. A Foreman who is allowed to access all of the assets. Furthermore, only the Foreman is allowed to control the robot in the manufacturing area. 2. A Worker who is not allowed to control the robot, and doesn't have privileges to see the number of employees wearing/not wearing helmets in each of the available areas. However, a Worker can see the total number of employees in each area. 3. HR personnel who are also not allowed to control the robot, but have access to view the number of employees wearing/not wearing helmets in each area. Dashboard sample architecture The project contains 3 main components: - A backend data service, which provides the mock data for the dashboard. - A fybrik module , responsible for intercepting HTTP requests sent from a user trying to read or write data. - A dashboard application, which performs HTTP requests and displays the responses for the user. For a more detailed description of the implementation visit fogProtect-dashboard-sample . Before you begin Install Fybrik using the Quick Start guide. A web browser. Create a namespace for the sample Create a new Kubernetes namespace and set it as the active namespace: kubectl create namespace fogprotect kubectl config set-context --current --namespace = fogprotect This enables easy cleanup once you're done experimenting with the sample. Backend data server The backend data server is responsible for reading or writing data to a database or any other resource. In this example the backend data server is a simple server that returns the mock data for the dashboard. Run the backend data server: export HELM_EXPERIMENTAL_OCI = 1 helm chart pull ghcr.io/fybrik/backend-server-chart:v0.0.1 helm chart export --destination = ./tmp ghcr.io/fybrik/backend-server-chart:v0.0.1 helm install rel1-backend-server ./tmp/backend_server Register the assets In this example we use 3 of the endpoints that the backend data server exposes. For each endpoint, we define an asset describing the data that will be returned as response from the backend data server. The description is used later to apply policies on the data. Register the assets: kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_get_safety_data.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_start_robot.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_stop_robot.yaml The identifier of the assets is <namespace>/<name> , and it should be used in the FybrikApplication that we will describe later on. For example the identifier of the asset defined in the file asset_start_robot.yaml is fogprotect/api.control.start-robot . Create JWT authentication key As the HTTP requests should contain the role of the user in the header, the dashboard application uses JWT to pass the JWT of the relevant role in the header. The JWT is authenticated using a secret key that we store as a secret in the cluster, in both fogprotect and fybrik-blueprints namespaces. Create the JWT secret: kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml kubectl apply -n fybrik-blueprints -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml Fybrik manager RBAC In order for the fybrik manager to be able to access the assets and to deploy the fybrik module that we created, give the manager the relevant RBAC authorization : kubectl apply -n fybrik-system -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/fybrik-system-manager-rbac.yaml Deploy the module In our case, the module as we described earlier is responsible for intercepting the HTTP requests received from the user. Once a request is received a decision must be made regarding the request, it should be either allowed, columns redacted or blocked depending on the role of the user. The decision is made using OpenPolicyAgent , and applying the policy described in About the dashboard application and specified here . Deploy the fybrik module and application: kubectl apply -n fybrik-system -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/rest-read-module.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/rest-read-application.yaml kubectl wait --for = condition = ready --all pod --timeout = 120s Deploy the dashboard We now deploy the dashboard that will display a table that contains the safety data of the factory, along with two buttons to start and stop the manufacturing robot. One can change the role of the user using a pull down menu. First create a port-forwarding to the service that will be intercepting the HTTP requests: kubectl -n fybrik-blueprints port-forward svc/rest-read 5559 :5559 & Afterwards, deploy the dashboard application: helm chart pull ghcr.io/fybrik/factory-gui-chart:v0.0.1 helm chart export --destination = ./tmp ghcr.io/fybrik/factory-gui-chart:v0.0.1 helm install rel1-factory-gui ./tmp/factory_gui kubectl wait --for = condition = ready --all pod --timeout = 120s Lastly, create a port-forwarding to the dashboard service in order to be able to open the dashboard in your browser: kubectl port-forward svc/factory-gui 3001 :3000 & Open your browser and go to http://127.0.0.1:3001. Cleanup Stop the port-forwarding: pgrep -f \"kubectl port-forward svc/factory-gui 3001:3000\" | xargs kill pgrep -f \"kubectl -n fybrik-blueprints port-forward svc/rest-read 5559:5559\" | xargs kill Remove the tmp directory that was created temporarily: rm -r tmp Delete the fybrik application and module: kubectl delete fybrikapplication rest-read kubectl -n fybrik-system delete fybrikmodule rest-read-module Delete the fogprotect namespace: kubectl delete namespace fogprotect Delete the RBAC authorization of the manager: kubectl -n fybrik-system delete -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/fybrik-system-manager-rbac.yaml Delete the JWT secret: kubectl delete -n fybrik-blueprints -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml","title":"Dashboard sample"},{"location":"samples/dashboard-sample/#dashboard-sample","text":"This sample shows how Fybrik enables a dashboard application to display data from a backend REST server and displaying only compliant information with the person operating the dashboard. In the sample we show how a Fybrik module that support REST protocol can control what information is displayed in the dashboard through policies. Specifically in this sample we demonstrate: - Just in time policy decisions - A Fybrik module that supports REST API Note: At this time some features in this demo use mocks as some underlying support in Fybrik is still pending.","title":"Dashboard sample"},{"location":"samples/dashboard-sample/#about-the-dashboard-application","text":"The dashboard application here is based on the smart manufacturing use-case of the European Horizon 2020 research project Fogprotect . Details for the use case are available here . The dashboard included in this sample is a mock dashboard of a remote manufacturing factory which can be controlled/supervised by expert operators from remote, without the need for the expert operator to be physically present in the factory. The scenario here is simplified for the purpose of this sample and demonstrates the following scenario: 1. A manufacturing robot that operates the manufacturing facility which can be activated or stopped remotely. 2. A safety dashboard observing the manufacturing floor which is composed of two areas. A production and a non-production area, that are observed by a video camera with image processing which monitors and counts the number of employees with and without helmets in each area. This is called the safety data of the factory. We demonstrate Fybrik abilities to control what data is seen by each role. In this scenario we show the following roles: 1. A Foreman who is allowed to access all of the assets. Furthermore, only the Foreman is allowed to control the robot in the manufacturing area. 2. A Worker who is not allowed to control the robot, and doesn't have privileges to see the number of employees wearing/not wearing helmets in each of the available areas. However, a Worker can see the total number of employees in each area. 3. HR personnel who are also not allowed to control the robot, but have access to view the number of employees wearing/not wearing helmets in each area.","title":"About the dashboard application"},{"location":"samples/dashboard-sample/#dashboard-sample-architecture","text":"The project contains 3 main components: - A backend data service, which provides the mock data for the dashboard. - A fybrik module , responsible for intercepting HTTP requests sent from a user trying to read or write data. - A dashboard application, which performs HTTP requests and displays the responses for the user. For a more detailed description of the implementation visit fogProtect-dashboard-sample .","title":"Dashboard sample architecture"},{"location":"samples/dashboard-sample/#before-you-begin","text":"Install Fybrik using the Quick Start guide. A web browser.","title":"Before you begin"},{"location":"samples/dashboard-sample/#create-a-namespace-for-the-sample","text":"Create a new Kubernetes namespace and set it as the active namespace: kubectl create namespace fogprotect kubectl config set-context --current --namespace = fogprotect This enables easy cleanup once you're done experimenting with the sample.","title":"Create a namespace for the sample"},{"location":"samples/dashboard-sample/#backend-data-server","text":"The backend data server is responsible for reading or writing data to a database or any other resource. In this example the backend data server is a simple server that returns the mock data for the dashboard. Run the backend data server: export HELM_EXPERIMENTAL_OCI = 1 helm chart pull ghcr.io/fybrik/backend-server-chart:v0.0.1 helm chart export --destination = ./tmp ghcr.io/fybrik/backend-server-chart:v0.0.1 helm install rel1-backend-server ./tmp/backend_server","title":"Backend data server"},{"location":"samples/dashboard-sample/#register-the-assets","text":"In this example we use 3 of the endpoints that the backend data server exposes. For each endpoint, we define an asset describing the data that will be returned as response from the backend data server. The description is used later to apply policies on the data. Register the assets: kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_get_safety_data.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_start_robot.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/assets/asset_stop_robot.yaml The identifier of the assets is <namespace>/<name> , and it should be used in the FybrikApplication that we will describe later on. For example the identifier of the asset defined in the file asset_start_robot.yaml is fogprotect/api.control.start-robot .","title":"Register the assets"},{"location":"samples/dashboard-sample/#create-jwt-authentication-key","text":"As the HTTP requests should contain the role of the user in the header, the dashboard application uses JWT to pass the JWT of the relevant role in the header. The JWT is authenticated using a secret key that we store as a secret in the cluster, in both fogprotect and fybrik-blueprints namespaces. Create the JWT secret: kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml kubectl apply -n fybrik-blueprints -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml","title":"Create JWT authentication key"},{"location":"samples/dashboard-sample/#fybrik-manager-rbac","text":"In order for the fybrik manager to be able to access the assets and to deploy the fybrik module that we created, give the manager the relevant RBAC authorization : kubectl apply -n fybrik-system -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/fybrik-system-manager-rbac.yaml","title":"Fybrik manager RBAC"},{"location":"samples/dashboard-sample/#deploy-the-module","text":"In our case, the module as we described earlier is responsible for intercepting the HTTP requests received from the user. Once a request is received a decision must be made regarding the request, it should be either allowed, columns redacted or blocked depending on the role of the user. The decision is made using OpenPolicyAgent , and applying the policy described in About the dashboard application and specified here . Deploy the fybrik module and application: kubectl apply -n fybrik-system -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/rest-read-module.yaml kubectl apply -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/rest-read-application.yaml kubectl wait --for = condition = ready --all pod --timeout = 120s","title":"Deploy the module"},{"location":"samples/dashboard-sample/#deploy-the-dashboard","text":"We now deploy the dashboard that will display a table that contains the safety data of the factory, along with two buttons to start and stop the manufacturing robot. One can change the role of the user using a pull down menu. First create a port-forwarding to the service that will be intercepting the HTTP requests: kubectl -n fybrik-blueprints port-forward svc/rest-read 5559 :5559 & Afterwards, deploy the dashboard application: helm chart pull ghcr.io/fybrik/factory-gui-chart:v0.0.1 helm chart export --destination = ./tmp ghcr.io/fybrik/factory-gui-chart:v0.0.1 helm install rel1-factory-gui ./tmp/factory_gui kubectl wait --for = condition = ready --all pod --timeout = 120s Lastly, create a port-forwarding to the dashboard service in order to be able to open the dashboard in your browser: kubectl port-forward svc/factory-gui 3001 :3000 & Open your browser and go to http://127.0.0.1:3001.","title":"Deploy the dashboard"},{"location":"samples/dashboard-sample/#cleanup","text":"Stop the port-forwarding: pgrep -f \"kubectl port-forward svc/factory-gui 3001:3000\" | xargs kill pgrep -f \"kubectl -n fybrik-blueprints port-forward svc/rest-read 5559:5559\" | xargs kill Remove the tmp directory that was created temporarily: rm -r tmp Delete the fybrik application and module: kubectl delete fybrikapplication rest-read kubectl -n fybrik-system delete fybrikmodule rest-read-module Delete the fogprotect namespace: kubectl delete namespace fogprotect Delete the RBAC authorization of the manager: kubectl -n fybrik-system delete -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/fybrik-system-manager-rbac.yaml Delete the JWT secret: kubectl delete -n fybrik-blueprints -f https://raw.githubusercontent.com/fybrik/fogProtect-dashboard-sample/main/secrets/jwt_key_secret.yaml","title":"Cleanup"},{"location":"samples/notebook/","text":"Notebook sample This sample shows how Fybrik enables a Jupyter notebook workload to access a dataset. It demonstrates how policies are seamlessly applied when accessing the dataset classified as financial data. In this sample you play multiple roles: As a data owner you upload a dataset and register it in a data catalog As a data steward you setup data governance policies As a data user you specify your data usage requirements and use a notebook to consume the data Before you begin Install Fybrik using the Quick Start guide. This sample assumes the use of the built-in catalog, Open Policy Agent (OPA) and flight module. A web browser. Create a namespace for the sample Create a new Kubernetes namespace and set it as the active namespace: kubectl create namespace fybrik-notebook-sample kubectl config set-context --current --namespace = fybrik-notebook-sample This enables easy cleanup once you're done experimenting with the sample. Prepare a dataset to be accessed by the notebook This sample uses the Synthetic Financial Datasets For Fraud Detection dataset 1 as the data that the notebook needs to read. Download and extract the file to your machine. You should now see a file named PS_20174392719_1491204439457_log.csv . Alternatively, use a sample of 100 lines of the same dataset by downloading PS_20174392719_1491204439457_log.csv from GitHub. Upload the CSV file to an object storage of your choice such as AWS S3, IBM Cloud Object Storage or Ceph. Make a note of the service endpoint, bucket name, and access credentials. You will need them later. Setup and upload to localstack For experimentation you can install localstack to your cluster instead of using a cloud service. Define variables for access key and secret key export ACCESS_KEY = \"myaccesskey\" export SECRET_KEY = \"mysecretkey\" Install localstack to the currently active namespace and wait for it to be ready: helm repo add localstack-charts https://localstack.github.io/helm-charts helm install localstack localstack-charts/localstack --set startServices = \"s3\" --set service.type = ClusterIP kubectl wait --for = condition = ready --all pod -n fybrik-notebook-sample --timeout = 120s Create a port-forward to communicate with localstack server: kubectl port-forward svc/localstack 4566 :4566 & Use AWS CLI to upload the dataset to a new created bucket in the localstack server: export ENDPOINT = \"http://127.0.0.1:4566\" export BUCKET = \"demo\" export OBJECT_KEY = \"PS_20174392719_1491204439457_log.csv\" export FILEPATH = \"/path/to/PS_20174392719_1491204439457_log.csv\" aws configure set aws_access_key_id ${ ACCESS_KEY } && aws configure set aws_secret_access_key ${ SECRET_KEY } && aws --endpoint-url = ${ ENDPOINT } s3api create-bucket --bucket ${ BUCKET } && aws --endpoint-url = ${ ENDPOINT } s3api put-object --bucket ${ BUCKET } --key ${ OBJECT_KEY } --body ${ FILEPATH } Register the dataset in a data catalog Register the credentials required for accessing the dataset. Replace the values for access_key and secret_key with the values from the object storage service that you used and run: cat << EOF | kubectl apply -f - apiVersion : v1 kind : Secret metadata : name : paysim-csv type : Opaque stringData : access_key : \"${ACCESS_KEY}\" secret_key : \"${SECRET_KEY}\" EOF Then, register the data asset itself in the catalog. Replace the values for endpoint , bucket and objectKey with values from the object storage service that you used and run: cat << EOF | kubectl apply -f - apiVersion : katalog.fybrik.io/v1alpha1 kind : Asset metadata : name : paysim-csv spec : secretRef : name : paysim-csv details : dataFormat : csv connection : name : s3 s3 : endpoint : \"http://localstack.fybrik-notebook-sample.svc.cluster.local:4566\" bucket : \"demo\" objectKey : \"PS_20174392719_1491204439457_log.csv\" metadata : name : Synthetic Financial Datasets For Fraud Detection geography : theshire tags : finance : true columns : - name : nameOrig tags : PII : true - name : oldbalanceOrg tags : PII : true - name : newbalanceOrig tags : PII : true EOF The asset is now registered in the catalog. The identifier of the asset is fybrik-notebook-sample/paysim-csv (i.e. <namespace>/<name> ). You will use that name in the FybrikApplication later. Notice the assetMetadata field above. It specifies the dataset geography and tags. These attributes can later be used in policies. For example, in the yaml above, the geography is set to theshire , you need make sure it is same with the region of your fybrik control plane, you can get the information with the below command: kubectl get configmap cluster-metadata -n fybrik-system -o 'jsonpath={.data.Region}' Quick Start installs a fybrik control plane with the region theshire by default. If you change it or the geography in the yaml above, a copy module will be required by the policies, but we do not install any copy module in the Quick Start . Define data access policies Define an OpenPolicyAgent policy to redact the columns tagged as PII for datasets tagged with finance . Below is the policy (written in Rego language): package dataapi.authz rule[{\"action\": {\"name\":\"RedactAction\", \"columns\": column_names}, \"policy\": description}] { description := \"Redact columns tagged as PII in datasets tagged with finance = true\" input.action.actionType == \"read\" input.resource.metadata.tags.finance column_names := [input.resource.metadata.columns[i].name | input.resource.metadata.columns[i].tags.PII] count(column_names) > 0 } In this sample only the policy above is applied. Copy the policy to a file named sample-policy.rego and then run: kubectl -n fybrik-system create configmap sample-policy --from-file = sample-policy.rego kubectl -n fybrik-system label configmap sample-policy openpolicyagent.org/policy = rego while [[ $( kubectl get cm sample-policy -n fybrik-system -o 'jsonpath={.metadata.annotations.openpolicyagent\\.org/policy-status}' ) ! = '{\"status\":\"ok\"}' ]] ; do echo \"waiting for policy to be applied\" && sleep 5 ; done You can similarly apply a directory holding multiple rego files. Deploy a Jupyter notebook In this sample a Jupyter notebook is used as the user workload and its business logic requires reading the asset that we registered (e.g., for creating a fraud detection model). Deploy a notebook to your cluster: JupyterLab Kubeflow Deploy JupyterLab: kubectl create deployment my-notebook --image = jupyter/base-notebook --port = 8888 -- start.sh jupyter lab --LabApp.token = '' kubectl set env deployment my-notebook JUPYTER_ENABLE_LAB = yes kubectl label deployment my-notebook app.kubernetes.io/name = my-notebook kubectl wait --for = condition = available --timeout = 120s deployment/my-notebook kubectl expose deployment my-notebook --port = 80 --target-port = 8888 Create a port-forward to communicate with JupyterLab: kubectl port-forward svc/my-notebook 8080 :80 & Open your browser and go to http://localhost:8080/ . Create a new notebook in the server Ensure that Kubeflow is installed in your cluster Create a port-forward to communicate with Kubeflow: kubectl port-forward svc/istio-ingressgateway -n istio-system 8080 :80 & Open your browser and go to http://localhost:8080/ . Click Start Setup and then Finish (use the anonymous namespace). Click Notebook Servers (in the left). In the notebooks page select in the top left the anonymous namespace and then click New Server . In the notebook server creation page, set my-notebook in the Name box and then click Launch . Wait for the server to become ready. Click Connect and create a new notebook in the server. Create a FybrikApplication resource for the notebook Create a FybrikApplication resource to register the notebook workload to the control plane of Fybrik: cat <<EOF | kubectl apply -f - apiVersion : app.fybrik.io/v1alpha1 kind : FybrikApplication metadata : name : my-notebook labels : app : my-notebook spec : selector : workloadSelector : matchLabels : app : my-notebook appInfo : intent : Fraud Detection data : - dataSetID : \"fybrik-notebook-sample/paysim-csv\" requirements : interface : protocol : fybrik-arrow-flight EOF Notice that: The selector field matches the labels of our Jupyter notebook workload. The data field includes a dataSetID that matches the asset identifier in the catalog. The protocol indicates that the developer wants to consume the data using Apache Arrow Flight. For some protocols a dataformat can be specified as well (e.g., s3 protocol and parquet format). Run the following command to wait until the FybrikApplication is ready: while [[ $( kubectl get fybrikapplication my-notebook -o 'jsonpath={.status.ready}' ) ! = \"true\" ]] ; do echo \"waiting for FybrikApplication\" && sleep 5 ; done Read the dataset from the notebook In your terminal , run the following command to print the endpoint to use for reading the data. It fetches the code from the FybrikApplication resource: ENDPOINT_SCHEME = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.scheme } ) ENDPOINT_HOSTNAME = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.hostname } ) ENDPOINT_PORT = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.port } ) printf \" ${ ENDPOINT_SCHEME } :// ${ ENDPOINT_HOSTNAME } : ${ ENDPOINT_PORT } \" The next steps use the endpoint to read the data in a python notebook Insert a new notebook cell to install pandas and pyarrow packages: % pip install pandas pyarrow Insert a new notebook cell to read the data using the endpoint value extracted from the FybrikApplication in the previous step: import json import pyarrow.flight as fl import pandas as pd # Create a Flight client client = fl.connect ( '<ENDPOINT>' ) # Prepare the request request = { \"asset\" : \"fybrik-notebook-sample/paysim-csv\" , # To request specific columns add to the request a \"columns\" key with a list of column names # \"columns\": [...] } # Send request and fetch result as a pandas DataFrame info = client.get_flight_info ( fl.FlightDescriptor.for_command ( json.dumps ( request ))) reader: fl.FlightStreamReader = client.do_get ( info.endpoints [ 0 ] .ticket ) df: pd.DataFrame = reader.read_pandas () Insert a new notebook cell with the following command to visualize the result: df Execute all notebook cells and notice that the nameOrig , oldbalanceOrg and newbalanceOrig columns appear redacted. Cleanup When you\u2019re finished experimenting with the notebook sample, clean it up: Stop kubectl port-forward processes (e.g., using pkill kubectl ) Delete the namespace created for this sample: kubectl delete namespace fybrik-notebook-sample Delete the policy created on fybrik-system namespace: kubectl -n fybrik-system delete configmap sample-policy Created by NTNU and shared under the CC BY-SA 4.0 license. \u21a9","title":"Notebook sample"},{"location":"samples/notebook/#notebook-sample","text":"This sample shows how Fybrik enables a Jupyter notebook workload to access a dataset. It demonstrates how policies are seamlessly applied when accessing the dataset classified as financial data. In this sample you play multiple roles: As a data owner you upload a dataset and register it in a data catalog As a data steward you setup data governance policies As a data user you specify your data usage requirements and use a notebook to consume the data","title":"Notebook sample"},{"location":"samples/notebook/#before-you-begin","text":"Install Fybrik using the Quick Start guide. This sample assumes the use of the built-in catalog, Open Policy Agent (OPA) and flight module. A web browser.","title":"Before you begin"},{"location":"samples/notebook/#create-a-namespace-for-the-sample","text":"Create a new Kubernetes namespace and set it as the active namespace: kubectl create namespace fybrik-notebook-sample kubectl config set-context --current --namespace = fybrik-notebook-sample This enables easy cleanup once you're done experimenting with the sample.","title":"Create a namespace for the sample"},{"location":"samples/notebook/#prepare-a-dataset-to-be-accessed-by-the-notebook","text":"This sample uses the Synthetic Financial Datasets For Fraud Detection dataset 1 as the data that the notebook needs to read. Download and extract the file to your machine. You should now see a file named PS_20174392719_1491204439457_log.csv . Alternatively, use a sample of 100 lines of the same dataset by downloading PS_20174392719_1491204439457_log.csv from GitHub. Upload the CSV file to an object storage of your choice such as AWS S3, IBM Cloud Object Storage or Ceph. Make a note of the service endpoint, bucket name, and access credentials. You will need them later. Setup and upload to localstack For experimentation you can install localstack to your cluster instead of using a cloud service. Define variables for access key and secret key export ACCESS_KEY = \"myaccesskey\" export SECRET_KEY = \"mysecretkey\" Install localstack to the currently active namespace and wait for it to be ready: helm repo add localstack-charts https://localstack.github.io/helm-charts helm install localstack localstack-charts/localstack --set startServices = \"s3\" --set service.type = ClusterIP kubectl wait --for = condition = ready --all pod -n fybrik-notebook-sample --timeout = 120s Create a port-forward to communicate with localstack server: kubectl port-forward svc/localstack 4566 :4566 & Use AWS CLI to upload the dataset to a new created bucket in the localstack server: export ENDPOINT = \"http://127.0.0.1:4566\" export BUCKET = \"demo\" export OBJECT_KEY = \"PS_20174392719_1491204439457_log.csv\" export FILEPATH = \"/path/to/PS_20174392719_1491204439457_log.csv\" aws configure set aws_access_key_id ${ ACCESS_KEY } && aws configure set aws_secret_access_key ${ SECRET_KEY } && aws --endpoint-url = ${ ENDPOINT } s3api create-bucket --bucket ${ BUCKET } && aws --endpoint-url = ${ ENDPOINT } s3api put-object --bucket ${ BUCKET } --key ${ OBJECT_KEY } --body ${ FILEPATH }","title":"Prepare a dataset to be accessed by the notebook"},{"location":"samples/notebook/#register-the-dataset-in-a-data-catalog","text":"Register the credentials required for accessing the dataset. Replace the values for access_key and secret_key with the values from the object storage service that you used and run: cat << EOF | kubectl apply -f - apiVersion : v1 kind : Secret metadata : name : paysim-csv type : Opaque stringData : access_key : \"${ACCESS_KEY}\" secret_key : \"${SECRET_KEY}\" EOF Then, register the data asset itself in the catalog. Replace the values for endpoint , bucket and objectKey with values from the object storage service that you used and run: cat << EOF | kubectl apply -f - apiVersion : katalog.fybrik.io/v1alpha1 kind : Asset metadata : name : paysim-csv spec : secretRef : name : paysim-csv details : dataFormat : csv connection : name : s3 s3 : endpoint : \"http://localstack.fybrik-notebook-sample.svc.cluster.local:4566\" bucket : \"demo\" objectKey : \"PS_20174392719_1491204439457_log.csv\" metadata : name : Synthetic Financial Datasets For Fraud Detection geography : theshire tags : finance : true columns : - name : nameOrig tags : PII : true - name : oldbalanceOrg tags : PII : true - name : newbalanceOrig tags : PII : true EOF The asset is now registered in the catalog. The identifier of the asset is fybrik-notebook-sample/paysim-csv (i.e. <namespace>/<name> ). You will use that name in the FybrikApplication later. Notice the assetMetadata field above. It specifies the dataset geography and tags. These attributes can later be used in policies. For example, in the yaml above, the geography is set to theshire , you need make sure it is same with the region of your fybrik control plane, you can get the information with the below command: kubectl get configmap cluster-metadata -n fybrik-system -o 'jsonpath={.data.Region}' Quick Start installs a fybrik control plane with the region theshire by default. If you change it or the geography in the yaml above, a copy module will be required by the policies, but we do not install any copy module in the Quick Start .","title":"Register the dataset in a data catalog"},{"location":"samples/notebook/#define-data-access-policies","text":"Define an OpenPolicyAgent policy to redact the columns tagged as PII for datasets tagged with finance . Below is the policy (written in Rego language): package dataapi.authz rule[{\"action\": {\"name\":\"RedactAction\", \"columns\": column_names}, \"policy\": description}] { description := \"Redact columns tagged as PII in datasets tagged with finance = true\" input.action.actionType == \"read\" input.resource.metadata.tags.finance column_names := [input.resource.metadata.columns[i].name | input.resource.metadata.columns[i].tags.PII] count(column_names) > 0 } In this sample only the policy above is applied. Copy the policy to a file named sample-policy.rego and then run: kubectl -n fybrik-system create configmap sample-policy --from-file = sample-policy.rego kubectl -n fybrik-system label configmap sample-policy openpolicyagent.org/policy = rego while [[ $( kubectl get cm sample-policy -n fybrik-system -o 'jsonpath={.metadata.annotations.openpolicyagent\\.org/policy-status}' ) ! = '{\"status\":\"ok\"}' ]] ; do echo \"waiting for policy to be applied\" && sleep 5 ; done You can similarly apply a directory holding multiple rego files.","title":"Define data access policies"},{"location":"samples/notebook/#deploy-a-jupyter-notebook","text":"In this sample a Jupyter notebook is used as the user workload and its business logic requires reading the asset that we registered (e.g., for creating a fraud detection model). Deploy a notebook to your cluster: JupyterLab Kubeflow Deploy JupyterLab: kubectl create deployment my-notebook --image = jupyter/base-notebook --port = 8888 -- start.sh jupyter lab --LabApp.token = '' kubectl set env deployment my-notebook JUPYTER_ENABLE_LAB = yes kubectl label deployment my-notebook app.kubernetes.io/name = my-notebook kubectl wait --for = condition = available --timeout = 120s deployment/my-notebook kubectl expose deployment my-notebook --port = 80 --target-port = 8888 Create a port-forward to communicate with JupyterLab: kubectl port-forward svc/my-notebook 8080 :80 & Open your browser and go to http://localhost:8080/ . Create a new notebook in the server Ensure that Kubeflow is installed in your cluster Create a port-forward to communicate with Kubeflow: kubectl port-forward svc/istio-ingressgateway -n istio-system 8080 :80 & Open your browser and go to http://localhost:8080/ . Click Start Setup and then Finish (use the anonymous namespace). Click Notebook Servers (in the left). In the notebooks page select in the top left the anonymous namespace and then click New Server . In the notebook server creation page, set my-notebook in the Name box and then click Launch . Wait for the server to become ready. Click Connect and create a new notebook in the server.","title":"Deploy a Jupyter notebook"},{"location":"samples/notebook/#create-a-fybrikapplication-resource-for-the-notebook","text":"Create a FybrikApplication resource to register the notebook workload to the control plane of Fybrik: cat <<EOF | kubectl apply -f - apiVersion : app.fybrik.io/v1alpha1 kind : FybrikApplication metadata : name : my-notebook labels : app : my-notebook spec : selector : workloadSelector : matchLabels : app : my-notebook appInfo : intent : Fraud Detection data : - dataSetID : \"fybrik-notebook-sample/paysim-csv\" requirements : interface : protocol : fybrik-arrow-flight EOF Notice that: The selector field matches the labels of our Jupyter notebook workload. The data field includes a dataSetID that matches the asset identifier in the catalog. The protocol indicates that the developer wants to consume the data using Apache Arrow Flight. For some protocols a dataformat can be specified as well (e.g., s3 protocol and parquet format). Run the following command to wait until the FybrikApplication is ready: while [[ $( kubectl get fybrikapplication my-notebook -o 'jsonpath={.status.ready}' ) ! = \"true\" ]] ; do echo \"waiting for FybrikApplication\" && sleep 5 ; done","title":"Create a FybrikApplication resource for the notebook"},{"location":"samples/notebook/#read-the-dataset-from-the-notebook","text":"In your terminal , run the following command to print the endpoint to use for reading the data. It fetches the code from the FybrikApplication resource: ENDPOINT_SCHEME = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.scheme } ) ENDPOINT_HOSTNAME = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.hostname } ) ENDPOINT_PORT = $( kubectl get fybrikapplication my-notebook -o jsonpath ={ .status.assetStates.fybrik-notebook-sample/paysim-csv.endpoint.fybrik-arrow-flight.port } ) printf \" ${ ENDPOINT_SCHEME } :// ${ ENDPOINT_HOSTNAME } : ${ ENDPOINT_PORT } \" The next steps use the endpoint to read the data in a python notebook Insert a new notebook cell to install pandas and pyarrow packages: % pip install pandas pyarrow Insert a new notebook cell to read the data using the endpoint value extracted from the FybrikApplication in the previous step: import json import pyarrow.flight as fl import pandas as pd # Create a Flight client client = fl.connect ( '<ENDPOINT>' ) # Prepare the request request = { \"asset\" : \"fybrik-notebook-sample/paysim-csv\" , # To request specific columns add to the request a \"columns\" key with a list of column names # \"columns\": [...] } # Send request and fetch result as a pandas DataFrame info = client.get_flight_info ( fl.FlightDescriptor.for_command ( json.dumps ( request ))) reader: fl.FlightStreamReader = client.do_get ( info.endpoints [ 0 ] .ticket ) df: pd.DataFrame = reader.read_pandas () Insert a new notebook cell with the following command to visualize the result: df Execute all notebook cells and notice that the nameOrig , oldbalanceOrg and newbalanceOrig columns appear redacted.","title":"Read the dataset from the notebook"},{"location":"samples/notebook/#cleanup","text":"When you\u2019re finished experimenting with the notebook sample, clean it up: Stop kubectl port-forward processes (e.g., using pkill kubectl ) Delete the namespace created for this sample: kubectl delete namespace fybrik-notebook-sample Delete the policy created on fybrik-system namespace: kubectl -n fybrik-system delete configmap sample-policy Created by NTNU and shared under the CC BY-SA 4.0 license. \u21a9","title":"Cleanup"},{"location":"tasks/control-plane-security/","text":"Enable Control Plane Security Kubernetes NetworkPolicies and optionally Istio are used to protect components of the control plane. Specifically, traffic to connectors that run as part of the control plane must be secured. Follow this page to enable control plane security. Ingress traffic policy The installation of Fybrik applies a Kubernetes NetworkPolicy resource to the fybrik-system namespace. This resource ensures that ingress traffic to connectors is only allowed from workloads that run in the fybrik-system namespace and thus disallow access to connectors from other namespaces or external parties. The NetworkPolicy is always created. However, your Kubernetes cluster must have a Network Plugin with NetworkPolicy support. Otherwise, NetworkPolicy resources will have no affect. While most Kubernetes distributions include a network plugin that enfoces network policies, some like Kind do not and require you to install a separate network plugin instead. Mutual TLS If Istio is installed in the cluster then you can use automatic mutual TLS to encrypt the traffic to the connectors. Follow these steps to enable mutual TLS: - Ensure that Istio 1.6 or above is installed. - Enable Istio sidecar injection in the fybrik-system namespace: kubectl label namespace fybrik-system istio-injection = enabled - Create Istio PeerAuthentication resource to enable mutual TLS between contains with Istio sidecars: cat << EOF | kubectl apply -f - apiVersion: \"security.istio.io/v1beta1\" kind: \"PeerAuthentication\" metadata: name: \"premissive-mtls-in-control-plane\" namespace: fybrik-system spec: mtls: mode: PERMISSIVE EOF - Create Istio Sidecar resource to allow any egress traffic from the control plane containers: cat << EOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Sidecar metadata: name: sidecar-default namespace: fybrik-system spec: egress: - hosts: - \"*/*\" outboundTrafficPolicy: mode: ALLOW_ANY EOF - Restart the control plane pods: kubectl delete pod --all -n fybrik-system","title":"Enable Control Plane Security"},{"location":"tasks/control-plane-security/#enable-control-plane-security","text":"Kubernetes NetworkPolicies and optionally Istio are used to protect components of the control plane. Specifically, traffic to connectors that run as part of the control plane must be secured. Follow this page to enable control plane security.","title":"Enable Control Plane Security"},{"location":"tasks/control-plane-security/#ingress-traffic-policy","text":"The installation of Fybrik applies a Kubernetes NetworkPolicy resource to the fybrik-system namespace. This resource ensures that ingress traffic to connectors is only allowed from workloads that run in the fybrik-system namespace and thus disallow access to connectors from other namespaces or external parties. The NetworkPolicy is always created. However, your Kubernetes cluster must have a Network Plugin with NetworkPolicy support. Otherwise, NetworkPolicy resources will have no affect. While most Kubernetes distributions include a network plugin that enfoces network policies, some like Kind do not and require you to install a separate network plugin instead.","title":"Ingress traffic policy"},{"location":"tasks/control-plane-security/#mutual-tls","text":"If Istio is installed in the cluster then you can use automatic mutual TLS to encrypt the traffic to the connectors. Follow these steps to enable mutual TLS: - Ensure that Istio 1.6 or above is installed. - Enable Istio sidecar injection in the fybrik-system namespace: kubectl label namespace fybrik-system istio-injection = enabled - Create Istio PeerAuthentication resource to enable mutual TLS between contains with Istio sidecars: cat << EOF | kubectl apply -f - apiVersion: \"security.istio.io/v1beta1\" kind: \"PeerAuthentication\" metadata: name: \"premissive-mtls-in-control-plane\" namespace: fybrik-system spec: mtls: mode: PERMISSIVE EOF - Create Istio Sidecar resource to allow any egress traffic from the control plane containers: cat << EOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Sidecar metadata: name: sidecar-default namespace: fybrik-system spec: egress: - hosts: - \"*/*\" outboundTrafficPolicy: mode: ALLOW_ANY EOF - Restart the control plane pods: kubectl delete pod --all -n fybrik-system","title":"Mutual TLS"},{"location":"tasks/custom-taxonomy/","text":"Background Fybrik acts as an orchestrator of independent components. For example, the author of the data governance policy manager, which provides the governance decisions, and the components that enforce those decisions are not necessarily the same. Thus, there is no common terminology between them. Similarly, the data formats and protocols defined in the data catalog may be defined differently than the components used for reading/writing data. In order to enable all these independent components to be used in a single architecture, Fybrik provides a taxonomy. It provides a mechanism for all the components to interact using a common dialect. Using a Custom Taxonomy for Resource Validation The project defines a set of immutable structural JSON schemas, or \"taxonomies\" for resources deployed in Fybrik. However, since the taxonomy is meant to be configurable, a taxonomy.json file is referenced from these schemas for any definition that is customizable. The taxonomy.json file is generated from a base taxonomy and zero or more taxonomy layers: The base taxonomy is maintained by the project and includes all of the structural definitions that are subject to customization (e.g.: tags, actions). The taxonomy layers are maintained by users and external systems that add customizations over the base taxonomy (e.g., defining specific tags, actions). This task describes how to deploy Fybrik with a custom taxonomy.json file that is generated with the Taxonomy Compile CLI tool. Taxonomy Compile CLI tool A CLI tool for compiling a base taxonomy and zero or more taxonomy layers is provided in our repo. The base taxonomy can be found in base.yaml can be found in charts/fybrik/files/taxonomy/taxonomy.json and example layers can be found in samples/taxonomy/example . The following command can be used from the root directory of our repo to run the Taxonomy Compile CLI tool. Usage: go run main.go taxonomy compile --out <outputFile> --base <baseFile> [ <layerFile> ... ] [ --codegen ] Flags: -b, --base string : File with base taxonomy definitions (required) --codegen : Best effort to make output suitable for code generation tools -o, --out string : Path for output file (default \"taxonomy.json\") This will generate a taxonomy.json file with the layers specified. Deploy Fybrik with Custom Taxonomy To deploy Fybrik with the generated taxonomy.json file, follow the quickstart guide but use the command below instead of helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait : helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait --set-file taxonomyOverride = taxonomy.json The --set-file flag will pass in your custom taxonomy.json file to use for taxonomy validation in Fybrik. If this flag is not provided, Fybrik will use the default taxonomy.json file with no layers compiled into it.","title":"Background"},{"location":"tasks/custom-taxonomy/#background","text":"Fybrik acts as an orchestrator of independent components. For example, the author of the data governance policy manager, which provides the governance decisions, and the components that enforce those decisions are not necessarily the same. Thus, there is no common terminology between them. Similarly, the data formats and protocols defined in the data catalog may be defined differently than the components used for reading/writing data. In order to enable all these independent components to be used in a single architecture, Fybrik provides a taxonomy. It provides a mechanism for all the components to interact using a common dialect.","title":"Background"},{"location":"tasks/custom-taxonomy/#using-a-custom-taxonomy-for-resource-validation","text":"The project defines a set of immutable structural JSON schemas, or \"taxonomies\" for resources deployed in Fybrik. However, since the taxonomy is meant to be configurable, a taxonomy.json file is referenced from these schemas for any definition that is customizable. The taxonomy.json file is generated from a base taxonomy and zero or more taxonomy layers: The base taxonomy is maintained by the project and includes all of the structural definitions that are subject to customization (e.g.: tags, actions). The taxonomy layers are maintained by users and external systems that add customizations over the base taxonomy (e.g., defining specific tags, actions). This task describes how to deploy Fybrik with a custom taxonomy.json file that is generated with the Taxonomy Compile CLI tool.","title":"Using a Custom Taxonomy for Resource Validation"},{"location":"tasks/custom-taxonomy/#taxonomy-compile-cli-tool","text":"A CLI tool for compiling a base taxonomy and zero or more taxonomy layers is provided in our repo. The base taxonomy can be found in base.yaml can be found in charts/fybrik/files/taxonomy/taxonomy.json and example layers can be found in samples/taxonomy/example . The following command can be used from the root directory of our repo to run the Taxonomy Compile CLI tool. Usage: go run main.go taxonomy compile --out <outputFile> --base <baseFile> [ <layerFile> ... ] [ --codegen ] Flags: -b, --base string : File with base taxonomy definitions (required) --codegen : Best effort to make output suitable for code generation tools -o, --out string : Path for output file (default \"taxonomy.json\") This will generate a taxonomy.json file with the layers specified.","title":"Taxonomy Compile CLI tool"},{"location":"tasks/custom-taxonomy/#deploy-fybrik-with-custom-taxonomy","text":"To deploy Fybrik with the generated taxonomy.json file, follow the quickstart guide but use the command below instead of helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait : helm install fybrik fybrik-charts/fybrik -n fybrik-system --wait --set-file taxonomyOverride = taxonomy.json The --set-file flag will pass in your custom taxonomy.json file to use for taxonomy validation in Fybrik. If this flag is not provided, Fybrik will use the default taxonomy.json file with no layers compiled into it.","title":"Deploy Fybrik with Custom Taxonomy"},{"location":"tasks/multicluster/","text":"Multicluster setup Fybrik is dynamic in its multi cluster capabilities in that it has abstractions to support multiple different cross-cluster orchestration mechanisms. Currently, only one multi cluster orchestration mechanism is implemented and is using Razee for the orchestration. Multicluster operation with Razee Razee is a multi-cluster continuous delivery tool for Kubernetes that can deploy software on remote clusters and track the deployment status of such deployments. There are multiple ways to run Razee. The two described here are a vanilla open source deployment on your own Kubernetes or as a managed service from a cloud provider. Due to the complex nature of installing Razee a managed service from a cloud provider is recommended. It's possible to define a multicluster group name that groups clusters that are used in a Fybrik instance. This will restrict the clusters that are usable in the Fybrik instance to the ones that are registered in the specified Razee group. This is especially helpful if Razee is also used for different purposes than Fybrik or multiple Fybrik instances should be used under the same Razee installation. In general there is a need for the following Razee components to be installed: Razee watch keeper (installed on all clusters) Razee cluster subscription manager (installed on all clusters) RazeeDash API (installed on coordinator cluster/as cloud service) Both methods below describe how the above components can be installed depending on what RazeeDash deployment method is used. Installing Razee on Kubernetes Coordinator cluster An installation of the open source components is described here . Please follow the instructions in the Razee documentation to install RazeeDash , Watch keeper and the cluster subscription agent . At the moment Razee supports GitHub, GitHub Enterprise and BitBucket for the OAUTH Authentication of this installation. Please be aware that the RazeeDash API needs to be reachable from all clusters. Thus, there may be the need for routes, ingresses or node ports in order to expose it to other networks and clusters. Once RazeeDash is installed the UI can be used to group registered clusters in a multicluster group that can be configured below. The API Key can also be retrieved from the UI following these two steps. From the RazeeDash console, click the arrow icon in the upper right corner. Then, select Profile. Copy the API key value. If no API key exists, click Generate to generate one. In order to configure Fybrik to use the installed Razee on Kubernetes the values of the helm charts have to be adapted to the following: coordinator: razee: # URL for Razee deployment url: \"https://your-razee-service:3333/graphql\" # Razee deployment with oauth API key authentication requires the apiKey parameter apiKey: \"<your Razee X_API_KEY>\" multiclusterGroup: \"<your group name>\" Remote cluster The remote clusters only need the watch keeper and cluster subscription agents installed. The remote clusters do not need the coordinator component of Fybrik. It's enough to follow this guide to install the agents and configure a group via the RazeeDash UI if needed. The coordinator configuration would look like the following: coordinator: enabled: false Installing using IBM Satellite Config When using IBM Satellite Config the RazeeDash API is running as a service in the cloud and all CRD distribution is handled by the cloud. The process here describes how an already existing Kubernetes cluster can be registered and configured. Prerequisites: An IBM Cloud Account IBM Cloud Satellite service IAM API Keys with access to IBM Cloud Satellite service The step below has to be executed for each cluster that should be added to the Fybrik instance. This step is the same for coordinator and remote clusters. In the IBM Satellite Cloud service under the Clusters tab click on Register cluster . Enter a cluster name in the popup dialog and click Register cluster . (Please don't use spaces in the name) The next dialog will offer you a kubectl command that can be executed on the cluster that should be attached. After executing the kubectl command the Razee services will be installed in the razeedeploy namespace and the cluster will show up in your cluster list (like in the picture above). This installs the watch keeper and cluster subscription components. The next step is to configure Fybrik to use IBM Satellite config as multicluster orchestrator. This configuration is done via a Kubernetes secret that is created by the helm chart. Overwriting the coordinator.razee values in your deployment will make use of the multicluster tooling. A configuration using IBM Satellite Config would look like the following for the coordinator cluster: coordinator: # Configures the Razee instance to be used by the coordinator manager in a multicluster setup razee: # IBM Cloud IAM API Key of a user or service account that have access to IBM Cloud Satellite Config iamKey: \"<your IAM API KEY key>\" multiclusterGroup: \"<your group name>\" For the remote cluster the coordinator will be disabled: coordinator: enabled: false","title":"Multicluster setup"},{"location":"tasks/multicluster/#multicluster-setup","text":"Fybrik is dynamic in its multi cluster capabilities in that it has abstractions to support multiple different cross-cluster orchestration mechanisms. Currently, only one multi cluster orchestration mechanism is implemented and is using Razee for the orchestration.","title":"Multicluster setup"},{"location":"tasks/multicluster/#multicluster-operation-with-razee","text":"Razee is a multi-cluster continuous delivery tool for Kubernetes that can deploy software on remote clusters and track the deployment status of such deployments. There are multiple ways to run Razee. The two described here are a vanilla open source deployment on your own Kubernetes or as a managed service from a cloud provider. Due to the complex nature of installing Razee a managed service from a cloud provider is recommended. It's possible to define a multicluster group name that groups clusters that are used in a Fybrik instance. This will restrict the clusters that are usable in the Fybrik instance to the ones that are registered in the specified Razee group. This is especially helpful if Razee is also used for different purposes than Fybrik or multiple Fybrik instances should be used under the same Razee installation. In general there is a need for the following Razee components to be installed: Razee watch keeper (installed on all clusters) Razee cluster subscription manager (installed on all clusters) RazeeDash API (installed on coordinator cluster/as cloud service) Both methods below describe how the above components can be installed depending on what RazeeDash deployment method is used.","title":"Multicluster operation with Razee"},{"location":"tasks/multicluster/#installing-razee-on-kubernetes","text":"","title":"Installing Razee on Kubernetes"},{"location":"tasks/multicluster/#coordinator-cluster","text":"An installation of the open source components is described here . Please follow the instructions in the Razee documentation to install RazeeDash , Watch keeper and the cluster subscription agent . At the moment Razee supports GitHub, GitHub Enterprise and BitBucket for the OAUTH Authentication of this installation. Please be aware that the RazeeDash API needs to be reachable from all clusters. Thus, there may be the need for routes, ingresses or node ports in order to expose it to other networks and clusters. Once RazeeDash is installed the UI can be used to group registered clusters in a multicluster group that can be configured below. The API Key can also be retrieved from the UI following these two steps. From the RazeeDash console, click the arrow icon in the upper right corner. Then, select Profile. Copy the API key value. If no API key exists, click Generate to generate one. In order to configure Fybrik to use the installed Razee on Kubernetes the values of the helm charts have to be adapted to the following: coordinator: razee: # URL for Razee deployment url: \"https://your-razee-service:3333/graphql\" # Razee deployment with oauth API key authentication requires the apiKey parameter apiKey: \"<your Razee X_API_KEY>\" multiclusterGroup: \"<your group name>\"","title":"Coordinator cluster"},{"location":"tasks/multicluster/#remote-cluster","text":"The remote clusters only need the watch keeper and cluster subscription agents installed. The remote clusters do not need the coordinator component of Fybrik. It's enough to follow this guide to install the agents and configure a group via the RazeeDash UI if needed. The coordinator configuration would look like the following: coordinator: enabled: false","title":"Remote cluster"},{"location":"tasks/multicluster/#installing-using-ibm-satellite-config","text":"When using IBM Satellite Config the RazeeDash API is running as a service in the cloud and all CRD distribution is handled by the cloud. The process here describes how an already existing Kubernetes cluster can be registered and configured. Prerequisites: An IBM Cloud Account IBM Cloud Satellite service IAM API Keys with access to IBM Cloud Satellite service The step below has to be executed for each cluster that should be added to the Fybrik instance. This step is the same for coordinator and remote clusters. In the IBM Satellite Cloud service under the Clusters tab click on Register cluster . Enter a cluster name in the popup dialog and click Register cluster . (Please don't use spaces in the name) The next dialog will offer you a kubectl command that can be executed on the cluster that should be attached. After executing the kubectl command the Razee services will be installed in the razeedeploy namespace and the cluster will show up in your cluster list (like in the picture above). This installs the watch keeper and cluster subscription components. The next step is to configure Fybrik to use IBM Satellite config as multicluster orchestrator. This configuration is done via a Kubernetes secret that is created by the helm chart. Overwriting the coordinator.razee values in your deployment will make use of the multicluster tooling. A configuration using IBM Satellite Config would look like the following for the coordinator cluster: coordinator: # Configures the Razee instance to be used by the coordinator manager in a multicluster setup razee: # IBM Cloud IAM API Key of a user or service account that have access to IBM Cloud Satellite Config iamKey: \"<your IAM API KEY key>\" multiclusterGroup: \"<your group name>\" For the remote cluster the coordinator will be disabled: coordinator: enabled: false","title":"Installing using IBM Satellite Config"},{"location":"tasks/performance/","text":"Performance When using many fybric applications at the same time the CRD operations may take some time. This is due to the default concurrency of controllers being one at a time and the Kubernetes client being rate limited by default. In order to increase the parallelism there are multiple parameters that can be controlled. Each controller parallelism (for each fybrik CRD) can be controlled separately. When increasing this number it's highly recommended to also increase the managers Kubernetes client QPS and Boost settings so that the controller won't be limited by the amount of queries it can execute to the Kubernetes API. An adapted helm values configuration looks like the following: # Manager component manager: extraEnvs: - name: APPLICATION_CONCURRENT_RECONCILES value: \"5\" - name: BLUEPRINT_CONCURRENT_RECONCILES value: \"20\" - name: PLOTTER_CONCURRENT_RECONCILES value: \"2\" - name: CLIENT_QPS value: \"100.0\" - name: CLIENT_BURST value: \"200\" Please notice that QPS is a float while the other values are integer values.","title":"Performance"},{"location":"tasks/performance/#performance","text":"When using many fybric applications at the same time the CRD operations may take some time. This is due to the default concurrency of controllers being one at a time and the Kubernetes client being rate limited by default. In order to increase the parallelism there are multiple parameters that can be controlled. Each controller parallelism (for each fybrik CRD) can be controlled separately. When increasing this number it's highly recommended to also increase the managers Kubernetes client QPS and Boost settings so that the controller won't be limited by the amount of queries it can execute to the Kubernetes API. An adapted helm values configuration looks like the following: # Manager component manager: extraEnvs: - name: APPLICATION_CONCURRENT_RECONCILES value: \"5\" - name: BLUEPRINT_CONCURRENT_RECONCILES value: \"20\" - name: PLOTTER_CONCURRENT_RECONCILES value: \"2\" - name: CLIENT_QPS value: \"100.0\" - name: CLIENT_BURST value: \"200\" Please notice that QPS is a float while the other values are integer values.","title":"Performance"},{"location":"tasks/using-opa/","text":"Using OPA for Data Governance Open Policy Agent may be used as a data governance policy engine with Fybrik via the connector mechanism. When OPA is used for data governance, it is deployed as a stand-alone service. Policies are defined in rego and uploaded to OPA. Fybrik Default Policies Fybrik denys by default any request if no rule is triggered. This behavior can be changed to allow by default by creating the following rule and upload it to OPA using methods described in this page: package dataapi.authz rule [{}] { true } You can also add conditions like rule[{}] { // conditions here } The verdict allow will be reached only if the conditions hold, and no other rule has been triggered, e.g. a rule requiring column redaction. Managing OPA policies There are several ways to manage policies and data of the OPA service. One simple approach is to use OPA kube-mgmt and manage Rego policies in Kubernetes Configmap resources. By default, Fybrik installs OPA with kube-mgmt enabled. The following two sections show how to use OPA with kube-mgmt. Warning Due to size limits you must ensure that each configmap is smaller than 1MB when base64 encoded. Using a configmap YAML Create a configmap with a Rego policy and a openpolicyagent.org/policy=rego label in the fybrik-system namespace: apiVersion : v1 kind : ConfigMap metadata : name : <policy-name> namespace : fybrik-system labels : openpolicyagent.org/policy : rego data : main : | <you rego policy here> Apply the configmap: kubectl apply -f <policy-name>.yaml To remove the policy just remove the configmap: kubectl delete -f <policy-name>.yaml Using a Rego file You can use kubectl to create a configmap from a Rego file. To create a configmap named <policy-name> from a Rego file in path <policy-name.rego> : kubectl create configmap <policy-name> --from-file = main = <policy-name.rego> -n fybrik-system kubectl label configmap <policy-name> openpolicyagent.org/policy = rego -n fybrik-system Delete the policy with kubectl delete configmap <policy-name> -n fybrik-system . Using opaServer.bootstrapPolicies field Another method to upload policies to OPA is to write them as opaServer.bootstrapPolicies field in values.yaml file used for the Fybrik deployment. In this approach the policies are uploaded upon OPA startup. opaServer: # Bootstrap policies to load upon startup bootstrapPolicies: allowSamplePolicy: | - package dataapi.authz rule [{}] { true }","title":"Using OPA for Data Governance"},{"location":"tasks/using-opa/#using-opa-for-data-governance","text":"Open Policy Agent may be used as a data governance policy engine with Fybrik via the connector mechanism. When OPA is used for data governance, it is deployed as a stand-alone service. Policies are defined in rego and uploaded to OPA.","title":"Using OPA for Data Governance"},{"location":"tasks/using-opa/#fybrik-default-policies","text":"Fybrik denys by default any request if no rule is triggered. This behavior can be changed to allow by default by creating the following rule and upload it to OPA using methods described in this page: package dataapi.authz rule [{}] { true } You can also add conditions like rule[{}] { // conditions here } The verdict allow will be reached only if the conditions hold, and no other rule has been triggered, e.g. a rule requiring column redaction.","title":"Fybrik Default Policies"},{"location":"tasks/using-opa/#managing-opa-policies","text":"There are several ways to manage policies and data of the OPA service. One simple approach is to use OPA kube-mgmt and manage Rego policies in Kubernetes Configmap resources. By default, Fybrik installs OPA with kube-mgmt enabled. The following two sections show how to use OPA with kube-mgmt. Warning Due to size limits you must ensure that each configmap is smaller than 1MB when base64 encoded.","title":"Managing OPA policies"},{"location":"tasks/using-opa/#using-a-configmap-yaml","text":"Create a configmap with a Rego policy and a openpolicyagent.org/policy=rego label in the fybrik-system namespace: apiVersion : v1 kind : ConfigMap metadata : name : <policy-name> namespace : fybrik-system labels : openpolicyagent.org/policy : rego data : main : | <you rego policy here> Apply the configmap: kubectl apply -f <policy-name>.yaml To remove the policy just remove the configmap: kubectl delete -f <policy-name>.yaml","title":"Using a configmap YAML"},{"location":"tasks/using-opa/#using-a-rego-file","text":"You can use kubectl to create a configmap from a Rego file. To create a configmap named <policy-name> from a Rego file in path <policy-name.rego> : kubectl create configmap <policy-name> --from-file = main = <policy-name.rego> -n fybrik-system kubectl label configmap <policy-name> openpolicyagent.org/policy = rego -n fybrik-system Delete the policy with kubectl delete configmap <policy-name> -n fybrik-system .","title":"Using a Rego file"},{"location":"tasks/using-opa/#using-opaserverbootstrappolicies-field","text":"Another method to upload policies to OPA is to write them as opaServer.bootstrapPolicies field in values.yaml file used for the Fybrik deployment. In this approach the policies are uploaded upon OPA startup. opaServer: # Bootstrap policies to load upon startup bootstrapPolicies: allowSamplePolicy: | - package dataapi.authz rule [{}] { true }","title":"Using opaServer.bootstrapPolicies field"}]}